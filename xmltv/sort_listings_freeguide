#!/usr/bin/perl -w
#
# sort_listings_freeguide
#
# (Adapted from sort_listings by Ed Avis, epa98@doc.ic.ac.uk, 2001-12-11)
#
# Sort the programmes in an XMLTV file according to:
#   - start time, or
#   - stop time, or
#   - internal channel name
#
# Then split the programmes into:
#   - a channels xml file
#   - a separate listings xml file for each day and channel
#
# This converts an XMLTV listing into a format suitable for the
# freeguide-tv GUI to display
#
# Usage: sort_listings_freeguide [input_file] [output_directory] [channel1] [channel2] ...
#
# where input_file is the output of a get_listings command
#
# -- Adapted from sort_listings (by Ed Avis) by Andy Balaam,
#    freeguide@artificialworlds.net, 2002-01-04
#
# Contributed to the XMLTV project to enhance the FreeGuide project.
# http://freeguide-tv.sourceforge.net
#

use strict;
use XMLTV;
use Date::Manip;
use Log::TraceMessages qw<t d>; Log::TraceMessages::check_argv(); $| = 1;
use Data::Dumper;
Date_Init(); # because we call ParseDate() while sorting

# Memoize some subroutines if possible
eval { require Memoize };
if ($@) {
    warn "could not load Memoize module, things will run slowly";
}
else {
    foreach (qw/Date_Cmp ParseDate programme_eq/) {
	Memoize::memoize($_) or die "cannot memoize $_: $!";
    }
    # clumpidx_cmp() isn't memoized, since it uses undef arguments and
    # they cause warnings.
    
}

# Prototype declarations
sub programme_cmp();
sub chan_cmp( $$ );
sub clumpidx_cmp( $$ );
sub overlap( $$ );
sub add_stop( $ );
sub programme_eq( $$ );

my $filename;
my $output_directory;
my @selected_channels;

# Will make flexible at some point
if(@ARGV < 3) {
	die "usage: $0 [sorted_input_file] [output_directory] [channel1] [channel2] ...\n";
}

$filename = $ARGV[0];
$output_directory = $ARGV[1];

my $i;
for($i=0;$i<@ARGV-2;$i++) {
	$selected_channels[$i]=$ARGV[$i+2];
}

my ($encoding, $credits, $channels, $progs) = @{read_data($filename)};
my @progs = @$progs;

# Split up programmes according to channel
my %chan;
my $i_prog;
my $i_chan;

foreach $i_prog (@progs) {
	# Only add a channel if it's selected
	# Could be done better?
	foreach $i_chan (@selected_channels) {
		if($i_chan eq $i_prog->{channel}) {
    		push @{$chan{$i_prog->{channel}}}, $i_prog;
			goto endchansloop;
		}
	}
	endchansloop:
}

# Sort each channel individually, and guess stop times.
foreach (keys %chan) {
    @{$chan{$_}} = sort programme_cmp @{$chan{$_}};
    add_stop($chan{$_});
}

# Remove duplicates and sanity-check that there is no overlap on a
# channel.
#
foreach (keys %chan) {
    my $progs = $chan{$_};
    my @new_progs;
    die if not @$progs;
    my $first = shift @$progs;
    while (@$progs) {
	my $second = shift @$progs;
	die if not defined $first or not defined $second;
	if (overlap($first, $second)) {
	    if (programme_eq($first, $second)) {
		# Quietly drop the duplicate.  We could have done the
		# programme_eq() step first but I thought (perhaps
		# wrongly) that it would be expensive, and best called
		# only when we know there is an overlap.  No overlap
		# implies not equal.
		#
		next;
	    }
	    else {
		local $^W = 0;
		warn <<END
overlapping programmes on channel $_:
    $first->{title}->[0]->[0]\tat $first->{start}-|$first->{stop}
and $second->{title}->[0]->[0]\tat $second->{start}-|$second->{stop}
END
  ;
	    }
	}
	push @new_progs, $first;
	$first = $second;
    }
    # Got to the last element.
    push @new_progs, $first;
    $chan{$_} = \@new_progs;
}


# Adapted 2002-01-04 by Andy Balaam - do not merge list back again,
# but instead write out channels and each day/channel listing as separate files

# Write out channels
write_data([ $encoding, $credits, $channels, "", "$output_directory/channels.xml" ]);

# Write out each channel/day
my $chankey;
foreach $chankey (keys %chan) {
	my @allprogs = @{$chan{$chankey}};
	my $prognum = 0;
	my $date;		# Date of the current programme
	my $newdate;		# Date object for the date of the new programme
	my $datetxt;		# Text for date to go into filename
	
	$date = ParseDate($allprogs[$prognum]->{start});
	$date = Date_SetTime($date, "06:00");
	
	@progs = ();
	
	my $thisprog;
	foreach $thisprog (@allprogs) {
	
		# Find the date/time of the next programme
		$newdate = ParseDate($thisprog->{start});
		
		# If we've moved to the next day
		my $datediff = DateCalc($date, $newdate);
		my $daysdiff = Delta_Format($datediff, 0, "%dv");
		#print "$datediff $daysdiff\n";
		if( $daysdiff > 0 ) {
			
			#$datetxt = "$year$mon$mday";
			$datetxt = UnixDate($date, "%Y%m%d");
			write_data([ $encoding, $credits, "", \@progs, "$output_directory/$chankey-$datetxt.fgd" ]);
			
			$date = $newdate;
			@progs = ();
		}
	
		# Add this programme to the programmes list
    	#push @progs, @{$chan{$_}};
		push @progs, $thisprog;
		
	}
	
	
}

# Removed by Andy Balaam 2002-01-04
# Write out the new document
#t 'writing out data';
#t 'new programmes list: ' . d \@progs;
#write_data([ $encoding, $credits, $channels, \@progs ]);
#write_data([ $encoding, $credits, $channels, \@progs, "$output_directory/test.xml" ]);

exit();


# Compare two programme hashes.
sub programme_cmp() {
    my $xa = $a; my $xb = $b;
    my $r;

    # Assume that {start} is always there, as it should be.
    my ($a_start, $b_start) = (ParseDate($xa->{start}), ParseDate($xb->{start}));
    if (not defined $a_start) {
	die "cannot parse start time: $xa->{start}";
    }
    if (not defined $b_start) {
	die "cannot parse start time: $xb->{start}";
    }
    $r = Date_Cmp($a_start, $b_start);
    t "compare start times: " . d $r;
    return $r if $r;

    # But {stop} is optional.  If both progs have stop we sort on it,
    # otherwise it is not used.  (It doesn't seem right to have
    # undefined values taking part in sort comparisons, and besides,
    # it stops sort_listings from being idempotent.)
    #
    my ($a_stop_u, $b_stop_u) = ($xa->{stop}, $xb->{stop});
    if (defined $a_stop_u and defined $b_stop_u) {
	my ($a_stop, $b_stop) = (ParseDate($a_stop_u), ParseDate($b_stop_u));
	if (not defined $a_stop) {
	    die "cannot parse stop time: $a_stop_u";
	}
	if (not defined $b_stop) {
	    die "cannot parse stop time: $b_stop_u";
	}
	$r = Date_Cmp($a_stop, $b_stop);
	t "compare stop times: " . d $r;
	return $r if $r;
    }

    # Channel.  Ideally would sort on pretty name, but no big deal.
    $r = $xa->{channel} cmp $xb->{channel};
    t "compare channels: " . d $r;
    return $r if $r;

    $r = clumpidx_cmp($xa->{clumpidx}, $xb->{clumpidx});
    t "compare clumpidxes: " . d $r;
    return $r if $r;

    t 'do not sort';
    # No warning, because we'll be weeding out duplicates later.  This
    # routine should just do what it's told and compare.
    #
    return 0;
}


# Compare indexes-within-clump
sub clumpidx_cmp( $$ ) {
    my ($A, $B) = @_;

    if (not defined $A and not defined $B) {
	return 0; # equal
    }
    elsif ((not defined $A and defined $B)
	   or (defined $A and not defined $B)) {
	warn "mismatching clumpidxs: one programme has, one doesn't";
	return undef;
    }
    elsif (defined $A and defined $B) {
	$A =~ m!^(\d+)/(\d+)$! or die "bad clumpidx $A";
	my ($ai, $num_in_clump) = ($1, $2);
	$B =~ m!^(\d+)/(\d+)$! or die "bad clumpidx $B";
	my $bi = $1;
	if ($2 != $num_in_clump) {
	    warn "clumpidx's $A and $B don't match";
	    return undef;
	}
	
	return $ai <=> $bi;
    }
    else { die }
}


# Test whether two programmes overlap in time.  This takes account of
# start time and stop time, and clumpidx (so two programmes with the same
# start and stop times, but different places within the clump, are not
# considered to overlap).
#
sub overlap( $$ ) {
    my ($xa, $xb) = @_;

    my ($xa_start, $xb_start) = (ParseDate($xa->{start}), ParseDate($xb->{start}));
    die "cannot parse start time: $xa->{start}" if not defined $xa_start;
    die "cannot parse start time: $xb->{start}" if not defined $xb_start;
    my ($xa_stop, $xb_stop);	
    for ($xa->{stop}) {
	if (defined) {
	    $xa_stop = ParseDate($_);
	    die "cannot parse stop time: $_" if not defined $xa_stop;
	}
    }
    for ($xb->{stop}) {
	if (defined) {
	    $xb_stop = ParseDate($_);
	    die "cannot parse stop time: $_" if not defined $xb_stop;
	}
    }

    # If we don't know the stop times we can't do an overlap test; if
    # we know only one stop time we can do only one half of the
    # test.  We assume no overlap if we can't prove otherwise.
    #
    { local $^W = 0;
      t "xa: $xa_start -| $xa_stop"; t "xb: $xb_start -| $xb_stop" }
    if ((
	 # XB starts while XA on
	 defined $xa_stop and Date_Cmp($xa_start, $xb_start) <= 0
	 and Date_Cmp($xb_start, $xa_stop) < 0
	) or (
	      # XA starts while XB on
	      defined $xb_stop and Date_Cmp($xb_start, $xa_start) <= 0
	      and Date_Cmp($xa_start, $xb_stop) < 0
	     )
       ) {
	my $cmp = clumpidx_cmp($xa->{clumpidx}, $xb->{clumpidx});
	if (not defined $cmp) {
	    # No clumpidxes, so must overlap.  (Also happens if
	    # the two indexes were not comparable - but that will
	    # have been warned about already.)
	    #
	    t 'no clumpidxes, overlap';
	    return 1;
	}
	t 'compared clumpidxes: same? ' . not $cmp;
	return not $cmp;
    }
    t 'no time overlap, returning 0';
    return 0;
}


# Add 'stop time' to a list of programmes (hashrefs).
# The stop time of a programme is the start time of the next.
#
# Parameters: reference to list of programmes, sorted by date, to be
# shown consecutively (except for 'clumps').
#
# Modifies the list passed in.
#
sub add_stop( $ ) {
    die 'usage: add_stop(ref to list of programme hashrefs)' if @_ != 1;
    my $l = shift;

    my $this_start; # Start time of current clump
    my $next_start; # Start time of next clump
    my $next_next_start; # Start time of next-but-one clump
    for (my $i = $#$l; $i >= 0; $i--) {
	my $this = $l->[$i];
	my $clumpidx = $this->{clumpidx};
	$clumpidx = '0/1' if not defined $clumpidx;
	$clumpidx =~ s!/\d+$!!; # not interested in clump size
	$clumpidx =~ m!^\d+$! or die "bad clumpidx '$_->{clumpidx}'";
	
	$this_start = $this->{start};
	if (not defined $this->{stop} and defined $next_start) {
	    if ($next_start ne $this_start) {
		$this->{stop} = $next_start;
	    }
	    else {
		# Special handling for overlapping programmes: going
		# backwards in time and finding one programme
		# immediately before another with the same start time.
		# We should guess the stop time to be the same as the
		# stop time for the overlapping programme.
		#
		# This is for the case you have the following three
		# programmes:
		#   A from 00 to ?
		#   A from 00 to ?
		#   B from 01 to 02
		# We need to make the two As have the same stop time.
		#
		$this->{stop} = $next_next_start
		  if defined $next_next_start;
	    }
	}

	if ($clumpidx == 0) {
	    # First programme in clump - we're going backwards, so
	    # next time we will move on to the previous clump.
	    #
	    if (not defined $next_start
		or $this_start ne $next_start) {
		($next_start, $next_next_start) = ($this_start, $next_start);
	    }
	}
    }
}


# Equality of two programmes.  The programme details are just text, so
# we can stringify the whole data structure and compare that.  We do
# assume that Data::Dumper will list hashes in a consistent order.  We
# don't care what the order is, just as long as it's the same each
# time.
#
sub programme_eq( $$ ) {
    t 'comparing programmes ' . d($_[0]) . ' and ' . d($_[1]);
    my $r = Dumper($_[0]) eq Dumper($_[1]);
    t "equal? $r";
    return $r;
}
