#!/usr/bin/perl -w
#
# $Id$
#
# Fetch UK television listings from the data provided by ananova.com.
#
# See release notes and/or cvs logs entries for module history
#
# -- Ed Avis, epa98@doc.ic.ac.uk
#

use strict;
use LWP::Simple;
use Getopt::Long;
use Tie::IxHash;
use Log::TraceMessages qw(t d); Log::TraceMessages::check_argv();
use Date::Manip;
use UK_TZ;
use XMLTV;
use Tie::RefHash;
use Term::ProgressBar;

# Prototype declarations
sub check_ananova_blurb();
sub get_regions();
sub get_dir();
sub get_ch_types();
sub usage();
sub get_file($$$);
sub date_programmes($$);
sub add_clumpidx($);
sub ch_output($);
sub get_ch_to_output();
sub get_channel_pkgs();
sub get_output_to_number();
sub channels_output();

# PHP page provided by Ananova to access their internal listings data.
# This is used as an inital substring of all the URLs gotten by this
# program.
#
my $A = 'http://www.ananova.com/tv_listings/_tv_raw.php';

# On Windows Date::Manip can have trouble finding the local timezone.
# Since the output listings shouldn't depend on the local timezone
# anyway, we just set it here.
#
Date_Init('TZ=UT');

# Things will go horribly wrong if Ananova change pages from one day
# to the next while the script is running.  Assume they do it at
# midnight.
#
my $today = ParseDate('today'); die if not defined $today;
END {
    if (UnixDate(ParseDate('today'), '%Q') ne UnixDate($today, '%Q')) {
	warn "current day has changed, results may be messed up\n";
    }
}

# What language the pages are in.  This has no real effect :-)
my $LANG = 'en';

# Check options.
my ($opt_days, $opt_help, $opt_cache, $opt_output);
GetOptions('days=i' => \$opt_days, 'help' => \$opt_help, 'cache:s' => \$opt_cache, 'output=s' => \$opt_output);
if ($opt_help) {
    print <<END
$0: get UK television listings in XMLTV format

The options available depend on what data is at the server.  Run with
no arguments to get a usage message and a default set of listings (7
days, London region).  It will write the listings to stdout, or to a
file if the --output option is used.
END
  ;
    exit(1);
}

if (defined $opt_cache) {
    # Undocumented option to speed up debugging (and reduce server
    # load).  Previous versions of getlistings_uk_ananova used Memoize
    # all over the place, but this program doesn't have as many
    # side-effect-free routines.  Many of the subs are self-memoizing
    # in that they update a global hash; others are run once and
    # return a hash.
    #
    if ($opt_cache eq '') {
	$opt_cache = "$0.cache";
    }
    print STDERR "using cache $opt_cache\n";
    require POSIX;
    require Memoize;
    Memoize::memoize('get',
		     SCALAR_CACHE => [ 'TIE', 'DB_File', $opt_cache,
				       POSIX::O_RDWR() | POSIX::O_CREAT(),
				       0666 ]);
}

# The date libraries, however, do benefit from memoization.  It's only
# about an 8% speed increase for the program as a whole, but worth it.
#
use Memoize;
eval { require Memoize };
if ($@) {
    warn "could not load Memoize module, things will run slowly\n";
}
else {
     foreach (qw(parse_uk_date ParseDate UnixDate DateCalc Date_Cmp
		 ParseDateDelta)) {
	 Memoize::memoize($_) or warn "cannot memoize $_";
     }
}

my $bar = new Term::ProgressBar('getting list of channels', 4);
my $copyright = check_ananova_blurb(); update $bar;

# Set up an XMLTV::Writer; print copyright and start of document.
# Ananova's data is in Latin-1.
#
my $writer;
if (defined $opt_output) {
	my $output = new IO::File(">$opt_output");
	$writer = new XMLTV::Writer(encoding => 'ISO-8859-1', OUTPUT => $output);
} else {
	$writer = new XMLTV::Writer(encoding => 'ISO-8859-1');
}

$writer->comment($copyright);
$writer->start({ 'source-info-url'     =>
	  'http://www.ananova.com/tv_listings/_tv_full_listings.html',
	         'source-info-name'    => 'Ananova',
	         'source-data-url'     => $A,
	         'generator-info-name' => 'XMLTV/0.4',
	         'generator-info-url'  =>
	  'http://www.doc.ic.ac.uk/~epa98/work/apps/xmltv/',
	       });

my $regions = get_regions(); update $bar;
#t 'regions: ' . d $regions;

# $ch_types maps Ananova channel id to type, $ch_pretty maps it to
# pretty name.  However, the pretty names in the channel file are not
# definitive; they're used to print progress messages, but the name in
# the listings file itself takes precedence.
#
my ($ch_types, $ch_pretty) = get_ch_types(); update $bar;
t '$ch_types=' . d $ch_types;
t '$ch_pretty=' . d $ch_pretty;
my %ch_pretty_definitive; # whether the name in $ch_pretty is defin.

# Maps ouput channel id to an additional pretty name for that channel.
my %output_to_number = get_output_to_number();
t '\%output_to_number=' . d \%output_to_number;

# Hardcoded channel packages.  It is planned to move these to separate
# files, but I didn't have time to reorganize the directory structure
# before the 0.4 release.
#
my %channel_pkgs = get_channel_pkgs();

# We've set the type of 'radio' and 'satellite' channels.  Now deal
# with the terrestrial channels, which have a region set.  We should
# find that every channel fits into radio, xor satellite, xor one
# particular region.
#
# We end up with a list of [ day, type, channel, filename ], where
# type is one of 'radio', 'satellite', or a region code.
#
my @files;
my %used_ch_types;

# Some entries in show=dir are for non-terrestrial channels which
# don't appear in show=channels.  This means they are old files which
# didn't get deleted, although they should have been.
#
my %duff_channels;
END {
    my @duff = sort keys %duff_channels;
    if (@duff) {
	# Don't bother warning, this error almost always happens and
	# the Ananova people are aware of the inconsistency.
	#

# 	warn <<END
# The following channels had listings files, but were not mentioned in
# the listing of channels:

# @duff

# The listings files are probably old ones, they haven\'t been fetched.
END
  ;
    }
}

foreach (get_dir()) {
    my ($orig, $day, $ch, $region) = @$_;
    my $has_type = (defined $ch_types->{$ch});
    my $has_region = (defined $region);
    ++ $used_ch_types{$ch};

    if (not $has_type and not $has_region) {
	# So the channel is not listed as 'radio' or 'satellite', and
	# neither does it have a region.  This probably means it's an
	# old file which is still lying around in dir.
	#
	$duff_channels{$ch} = 1;
    }
    elsif (not $has_type and $has_region) {
	$ch_types->{$ch} = $region;
	push @files, [ $day, $region, $ch, $orig ];
    }
    elsif ($has_type and not $has_region) {
	if ($ch_types->{$ch} eq 'satellite' or $ch_types->{$ch} eq 'radio') {
	    # Satellite and radio channels do not have a region, okay.
	    push @files, [ $day, $ch_types->{$ch}, $ch, $orig ];
	}
	else {
	    warn "channel $ch has unknown type $ch_types->{$ch}";
	}
    }
    elsif ($has_type and $has_region) {
	if ($ch_types->{$ch} eq $region) {
	    # Encountered the same region as before, okay.
	    push @files, [ $day, $region, $ch, $orig ];
	}
	else {
	    warn "channel $ch has changed from $ch_types->{$ch} to $region";
	}
    }
    else { die }
}
t 'files: ' . d \@files;
update $bar;

# Check that there are no redundant entries in the channel data.
foreach (keys %$ch_types) {
    unless ($used_ch_types{$_}) {
	warn "channels data mentions $_ ($ch_pretty->{$_}), but not used\n";
    }
}

# Now work out which of @files we actually want to download.
# %wanted_ch says which Ananova channel ids we want to download.
#
my (%type_pretty, %wanted_type, %wanted_ch);
my $want_all;
if (defined $ARGV[0] and $ARGV[0] eq 'ALL') {
    $want_all = 1;
}
else {
    %type_pretty = reverse %$regions;
    $type_pretty{$_} = $_ foreach qw(radio satellite);
    foreach my $arg (@ARGV) {
	my $t;
	
	# See whether the argument matches a region.
	foreach (sort keys %type_pretty) {
	    if ($type_pretty{$_} =~ /\Q$arg\E/i) {
		print STDERR "getting region $type_pretty{$_}\n";
		$t = $_;
		last;
	    }
	}
	if (defined $t) {
	    $wanted_type{$t}++
	      && warn "channel type $type_pretty{$t} mentioned twice\n";
	    next;
	}
	
	# Nope, but maybe it matches a channel package.
	foreach (sort keys %channel_pkgs) {
	    if ($_ eq $arg) {
		print STDERR "getting channel package $_\n";
		$t = $_;
		last;
	    }
	}
	if (defined $t) {
	    foreach (@{$channel_pkgs{$t}}) {
		++ $wanted_ch{$_};
	    }
	    next;
	}

	# Finally, perhaps it matches the name of a channel.
	foreach (sort keys %$ch_pretty) {
	    if ($ch_pretty->{$_} =~ /\Q$arg\E/i) {
		print STDERR "getting channel $ch_pretty->{$_}\n";
		$t = $_;
		last;
	    }
	}
	if (defined $t) {
	    $wanted_ch{$t}++
	      && warn "channel $ch_pretty->{$t} already chosen";
	    next;
	}
	
	if (not defined $t) {
	    warn "'$arg' does not match any known channel type, package or channel\n";
	    usage();
	}
    }
    if (not keys %wanted_type and not keys %wanted_ch) {
	my $default;
	foreach (keys %type_pretty) {
	    if ($type_pretty{$_} =~ /carlton/i) {
		$default = $_;
		++ $wanted_type{$_};
		last;
	    }
	}
	if (keys %wanted_type) {
	    warn "no channel types, packages or channels given, assuming $type_pretty{$default}\n";
	    usage();
	}
	else {
	    warn "no channel types, packages or channels given and default 'carlton' not found, "
	      . "giving up\n";
	    usage();
	    exit(1);
	}
    }
    die if not keys %wanted_type and not keys %wanted_ch;
}

# There used to be a warning that if you chose 'satellite' you'd need
# to also pick a terrestrial region to get channels like BBC1.  This
# is no longer the case since Ananova now has listings for BBC1
# Digital and so on.  Besides, with the new channel packages
# 'satellite' will probably not be used much.
#

# Filter out the files we want to download - those with the correct
# channel type.
#
@files = grep {
    ($want_all or $wanted_type{$_->[1]} or $wanted_ch{$_->[2]})
      && (not defined $opt_days or $opt_days >= $_->[0])
  } @files;

# We want to get them in day order, so that we can get the first day's
# listings first.  This is becuase we need to get a complete day to
# get the complete channel information, which must be written out
# before any programmes.
#
$bar = new Term::ProgressBar('downloading listings', scalar @files);
my $first_day;
my $wrote_channels = 0;
my @progs_todo;
foreach (sort { $a->[0] <=> $b->[0] } @files) {
    my ($day, $type, $ch, $filename) = @$_;
    t "getting file for day $day, type $type, ch $ch, filename $filename";
    die if not ($want_all or $wanted_type{$type} or $wanted_ch{$ch});
    die if defined $opt_days and $day > $opt_days;
    $first_day = $day if not defined $first_day;

    # Work out the actual day this number corresponds to: 1 is
    # today.
    #
    my $day_offset = $day-1;
    t 'day offset: ' . d $day_offset;
    my $day_date = DateCalc($today, "+ $day_offset days");
    die if not defined $day_date;

    # Get a list of programmes from this filename, fix the dates and
    # add clumpidxes.
    #
    my $progs = get_file($day_date, $ch, $filename);
    date_programmes($progs, $day_date);
    add_clumpidx($progs);

    # Check to see if we have to write channels data first.
    if (not $wrote_channels) {
	if ($day != $first_day) {
	    # Must have done a whole day's listings, channels are ready to
	    # write.
	    #
	    $writer->write_channels(channels_output());
	    $wrote_channels = 1;
	}
    }

    push @progs_todo, @$progs;
    if ($wrote_channels) {
	t 'channels have been written before, write programmes';
	$writer->write_programme($_) foreach @progs_todo;
	@progs_todo = ();
    }

    update $bar;
}

# In case we never got to the second day, make sure the pending stuff
# is written.
#
if (not $wrote_channels) {
    $writer->write_channels(channels_output());
    $writer->write_programme($_) foreach @progs_todo;
    $wrote_channels = 1; @progs_todo = ();
}

# Finish.
$writer->end();
exit();


# Check that the usage message has not changed (if it has, this
# program probably needs changing).  Returns the copyright message.
#
sub check_ananova_blurb() {
    for (get $A) {
	die "cannot get $A" if not defined;

	# Remove cruft and check it looks as expected.
	s/^\s*\#\s*//gm; s/(\s)\s+/$1/g;
	s/
useage: \?show=<request>
where request is one of \[regions\|channels\|dir\|<file>\]
\?show=regions outputs a list of regions and region codes
\?show=channels outputs a list of channel codes and names
\?show=dir outputs the list of currently valid file names.*//s
  or warn "usage message has changed to: $_\n";

	# There should be no need to fix non-ASCII characters since we
	# have set the XMLTV::Writer for Latin-1.
	#

	return $_;
    }
}


# Return a reference to an ordered hash mapping region pretty name to
# Ananova internal region name.
#
sub get_regions() {
    my $url =  "$A?show=regions";
    (my $data = get $url) or die "cannot get $url";
#    t "got regions page: $data";
    my %r; tie %r, 'Tie::IxHash';
    foreach (split /\n/, $data) {
	t "doing line: $_";
	s/^\s+//; s/\s+$//;
	s/\#.*//;
	next if $_ eq '';
	if (/^region\.((?:[a-z]+_)?\d+)=(.+)$/) {
	    $r{$2} = $1;
	}
	else {
	    warn "bad line from $url: $_";
	}
    }
    if (not keys %r) {
	warn "couldn't get any region data from $url";
    }
    return \%r;
}
    

# Get the list of Ananova 'filenames' and parse each filename into a
# tuple of:
#
# [ original filename, day number, channel id, region ]
#
# Region may be undef, and channel id will also contain the region
# details (so that bbc1_2 and bbc1ea_0 are distinct channels).
#
# Returns a list of these tuples (er, listrefs).
#
sub get_dir() {
    local $Log::TraceMessages::On = 0;
    my $url =  "$A?show=dir";
    (my $data = get $url) or die "cannot get $url";
#    t "got dir page: $data";

    my @r;
    my %warned_unknown_region;
    foreach (split /\n/, $data) {
	t "doing line: $_";
	s/^\s+//; s/\s+$//;
	s/\#.*//;
	next if $_ eq '';
	
	my $orig = $_;

	s/^day(\d+)_// or die "bad Ananova filename $_ (no 'dayX_')";
	my $day = $1;
	my $channel = $_;

	my $region;
	foreach my $r (values %$regions) {
	    if ($r =~ /\D/ && s/$r$//) {
		# Ends with the region code itself.  This isn't
		# applicable if the region code is just a number.
		#
		$region = $r;
		last;
	    }
	    
	    $r =~ /(\d+)$/ or die "bad region code $r";
#	    t "just the number of region: $1";
	    if (/_$1$/) {
		# Ends with _ and just the number of the region.
		$region = $r;
		last;
	    }
	}

	if (not defined $region) {
	    if (/^(?:[a-z]+_)?[a-z0-9]+$/) {
		# No region at all, okay.
	    }
	    else {
		unless ($warned_unknown_region{$_}++) {
		    warn "can't find region for channel id $_\n";
		}
	    }
	}

	push @r, [ $orig, $day, $channel, $region ];
    }
    return @r;
}


# Get details of the different channel names.  Returns a list of two
# hashrefs: the first maps channel internal name to type ('radio' or
# 'satellite'), the second maps it to pretty name.
#
sub get_ch_types() {
    local $Log::TraceMessages::On = 0;
    my $url =  "$A?show=channels";
    (my $data = get $url) or die "cannot get $url";
#    t "got channels page: $data";

    my (%type, %pretty);
    my %seen_pretty;
    foreach (split /\n/, $data) {
	t "doing line: $_";
	s/^\s+//; s/\s+$//;
	s/\#.*//;
	next if $_ eq '';
	
	if (/^(radio|satellite)\.([a-z0-9_]+)=(.+)$/) {
	    t 'matched';
	    my ($type, $ch, $pretty) = ($1, $2, $3);
	    t "type=$type, ch=$ch, pretty=$pretty";
	    if (defined $type{$ch}) {
		warn "channel $ch seen twice";
		next;
	    }
	    if ($seen_pretty{lc $pretty}++) {
		# FIXME kludge around fact that we _know_ Nickelodeon
		# is wrong: I've reported it but they haven't fixed it
		# yet.
		#
		unless ($pretty eq 'Nickelodeon') {
		    warn "channel pretty name $pretty seen twice";
		}
	    }

	    t "setting type of $ch to $type";
	    $type{$ch} = $type;
	    t "setting pretty name of $ch to $pretty";
	    $pretty{$ch} = $pretty;
	}
	else {
	    warn "bad line in channels listing: $_\n";
	}
    }
    return (\%type, \%pretty);
}


# Usage message
my $shown_usage = 0;
sub usage() {
    return if $shown_usage++;
    my $msg = <<END
usage: $0 [--days N] [--output filename] channel-spec...

There are three ways to choose which channels to download.  Pick a
terrestrial region or channel type from:

END
;
    $msg .= join(', ', sort values %type_pretty) . "\n";
    $msg .= <<END

'radio' means all radio stations and 'satellite' all satellite
channels.  But if you have satellite, you probably want to pick one
or more of the following channel packages:

END
;
    my %channel_pkgs = get_channel_pkgs();
    foreach (sort keys %channel_pkgs) {
        # FIXME some of the pretty names are not set because the
        # channel wasn't listed in show=dir.  We need to unify the
        # pretty names and 'extra pretty names' and make it so that
        # at least something is ready to display here.
        #
        $msg .= "$_: " . join(', ', map { $ch_pretty->{$_} || $_ }
                                        @{$channel_pkgs{$_}} ) . "\n\n";
    }

    $msg .= <<END
Or you can specify the names of individual channels directly.

You can abbreviate names by giving a case-insensitive substring, for
example 'Tyne Tees' could be abbreviated to 'tyne'.  The special value
'ALL' means get every available channel, but this gives a very big
output file!
END
  ;
    warn $msg;
}


# Get data for a particular day.
#
# Parameters:
#   date expected in file (in Date::Manip format)
#   channel id, used to check pretty name in file
#   'filename'
#
# Uses global $ch_types and $ch_pretty hashrefs.
#
# Returns: reference to list of programme details, or undef if error.
# These won't have proper start and stop times; instead they have a
# 'time' key and you should use date_programmes() or similar to fix up
# the list of programmes afterwards.  Also the channel is not
# included, you should add that to each programme (probably in RFC2838
# style) afterwards.
#
my (%warned_shorter, $warned_wrong_date); # cut down on duplicate warnings
sub get_file($$$) {
    my ($date_expected, $ch, $file) = @_;
    my $url =  "$A?show=$file";

    (my $data = get $url) or die "cannot get $url";

    my @lines = split /\n/, $data;
    foreach (@lines) { s/^\s+//; s/\s+$//; s/\#.*// }
    @lines = grep { length } @lines;

    if (not @lines) {
	# No non-comment lines.  This could be because the PHP script
	# is returning 'file not found'.  That happens if you request
	# the directory listing, it contains obsolete files which
	# (wrongly) are still around, and then your request for the
	# file itself is handled by a different box where the file is
	# in fact deleted.
	#
	if ($data =~ /\n\# $file does not exist$/) {
	    warn "file $file does not exist on server, probably should be removed from dir\n";
	    return undef;
	}
	else {
	    warn "cannot get data from $url, returns:\n$data";
	    return undef;
	}
    }

    # Check the date.  According to Ananova's comment there's some odd
    # procedure you have to follow to make sure it is correct.
    #
    my $page_date = shift @lines;
    if (not $page_date =~
/^((?:Sun|Mon|Tues|Wednes|Thurs|Fri|Satur)day)\|(\d\d)\|(\d\d)\|(\d\d\d\d)$/)
    {
	warn "bad date '$page_date' in file $url, skipping";
	return undef;
    }
    my ($weekday, $dd, $mm, $yyyy) = ($1, $2, $3, $4);
    t "got date: $weekday $yyyy-$mm-$dd";
    my $dp = ParseDate("$yyyy-$mm-$dd");
    if (not defined $dp) {
	warn "bad date '$page_date' in file $url, skipping";
	return undef;
    }
    t "parsed out date $dp, check it matches $weekday";
    if (UnixDate($dp, '%A') ne $weekday) {
	# Apparently you have to step backwards by one or two days
	# until the date matches the weekday given.
	#
	my $found = 0;
	foreach (0, 1) {
	    $dp = DateCalc($dp, '- 1 day'); die if not defined $dp;
	    if (UnixDate($dp, '%A') eq $weekday) {
		$found = 1;
		last;
	    }
	}
	if (not $found) {
	    warn "weekday of $page_date is wrong in $url (even tried going back a couple of days)";
	    return undef;
        }
    }

    # But does it match what we expect?
    if (UnixDate($dp, '%Q') ne UnixDate($date_expected, '%Q')) {
	if ($opt_cache) {
	    unless ($warned_wrong_date++) {
		warn "since cache is in use, ignoring wrong date in pages (eg $url)\n";
	    }
	}
	else {
	    warn "date from page $url (" . UnixDate($dp, '%Q') . ") is wrong (probably an old file)\n";
	    return undef;
	}
    }

    # Check the channel name is as expected (if we know what the
    # pretty name should be for this channel).
    #
    my $got_ch_pretty = shift @lines;
    my $expected_pretty_name = $ch_pretty->{$ch};
    if (defined $expected_pretty_name
	and $got_ch_pretty ne $expected_pretty_name) {
	if ($ch_pretty_definitive{$ch}) {
	    warn
"channel $ch changed name from '$expected_pretty_name' to '$got_ch_pretty'\n";
	}
	else {
	    # Not definitive, in other words the new name takes
	    # precedence (and is definitive).
	    #
	    $ch_pretty->{$ch} = $got_ch_pretty;
	    $ch_pretty_definitive{$ch} = 1;
	}
    }
    else {
	# Currently no pretty name defined.  Probably because it's a
	# terrestrial channel and wasn't mentioned in the channels
	# file.  We check elsewhere for channels in show=dir that
	# aren't in show=channels, so here we needn't bother with
	# validating, we can just set the name and carry on happily.
	#
	$ch_pretty->{$ch} = $got_ch_pretty;
    }

    my $copyright = pop @lines;
    if ($copyright !~ /^\(c\) Copyright/) {
	warn "strange copyright message: $copyright\n";
    }

    if (@lines and $lines[0] =~
	/^There are no listings available for this channel today\|\|/) {
	return [];
    }

    # Right, got that cruft out of the way, each remaining line is a
    # |-separated list of programme details.
    #
    my @r;
    my $prev_time;
    foreach (@lines) {
	my @fields = split /\|/, $_, -1; # toothpicks ahoy!
	my $num_fields = scalar @fields;
	if ($num_fields == 1 and $fields[0] =~ /copyright/i) {
	    next;
	}
	if ($num_fields < 17 or $num_fields >= 22) {
	    warn "wrong number of fields ($num_fields, need 17..21) "
	      . "in line from $url: $_\n";
	    warn "fields are: " . join("\n", @fields) . "\n";
	    warn "skipping line\n";
	    next;
	}
	my ($title, $time, $when, $episode_num, $episode_name, $cast,
	    $director, $duration, $desc, $type, $subtitled, $bw,
	    $stereo, $mono, $new, $repeat, $digital)
	  = @fields;
	my %p;

	# In the XMLTV format, title is multivalued, so it needs to be
	# a list.  Furthermore each element is itself a list of
	# [ string, language ].  Many other elements are like this.
	#
	$p{title} = [ [ $title, $LANG ] ];
	
	# The comment from Ananova says that the time is 'probably in
	# time zone existing at 5:00am of the correct file date'.  I
	# assume that means that it might not be, and it might instead
	# have an explicit timezone.  We'll just use the old
	# date-parsing routines to figure out the timezone.
	#
	# That means that for now, we add an element 'time' to the
	# programme details, and later on, date_programmes() turns
	# this into a proper start and stop time.
	#
	if (length $time) {
	    if (not $time =~ /^\d\d?:\d\d$/) {
		warn "bad time '$time' in line from page $url: $_";
		warn "skipping line";
		next;
	    }
	}
	else {
	    # No time was given for this programme.  This is probably
	    # because it's contained in the same 'clump' as the
	    # previous one, for example 'CBBC' at 6:45 is followed in
	    # the listings by 'Teletubbies' without a time.
	    #
	    # For this case, we give the programme the same time as
	    # the previous one.  That's the way it appears in the
	    # Ananova user-visible pages and it's what add_clumpidx()
	    # expects.
	    #
	    if (not defined $prev_time) {
		warn "no time for first line from page $url: $_";
		warn "skipping line";
		next;
	    }
	    $time = $prev_time;
	}

	# For sanity-checking the time against 'when',
	# comparing raw hours and minutes will probably be faster
	# than using Date::Manip.
	#
	$time =~ /^(\d\d?):(\d\d)$/ or die;
	my ($hours, $minutes) = ($1, $2);
	if (length($hours) == 1) {
	    $hours = "0$hours";
	    $time = "$hours:$minutes";
	}
	$p{time} = $time;
	$prev_time = $time;
	
	# The 'when' attribute can be DAYTIME, EVENING or LATENIGHT.
	# It seems a bit redundant to me.  But on the principle that
	# no scrap of information should be thrown away, we check that
	# it's sensible.
	#
	if ($when eq 'DAYTIME') {
	    if (5 <= $hours and $hours < 18) {
		# Daytime is between 05:00 and 18:00.  It overlaps
		# slightly with LATENIGHT.
		#
	    }
	    else {
		warn "time $time is wrongly considered 'DAYTIME' "
		  . "in line from url $url: $_\n";
	    }
	}
	elsif ($when eq 'EVENING') {
	    if (18 <= $hours) {
		# Evening is from 18:00 until midnight.
	    }
	    else {
		warn "time $time is wrongly considered 'EVENING' "
		  . "in line from url $url: $_\n";
	    }
	}
	elsif ($when eq 'LATENIGHT') {
	    # Latenight is until 07:00 (or sometimes a programme just
	    # beginning at that time is still latenight).  Annoyingly,
	    # 23:59 is also counted as latenight, so we'll say it runs
	    # from 23:00 to 07:00.
	    #
	    if (23 <= $hours
		or $hours < 7
		or ($hours == 7 and $minutes == 0)) {
		# Okay.
	    }
	    else {
		warn "time $time is wrongly considered 'LATENIGHT' "
		  . "in line from url $url: $_\n";
	    }
	}
	else {
	    warn "unknown 'when' specifier $when "
	      . "in line from url $url: $_";
	}

	# Episode number.
	if (length $episode_num) {
	    if ($episode_num =~ m!^[0-9/]+$!) {
		# Assume that Ananova numbers episodes from 1; but
		# XMLTV - like all good languages - counts from 0.
		#
		$episode_num =~ s/^(\d+)/$1 - 1/e;
		$p{'episode-num'} = [ $episode_num, 'xmltv_ns' ];
	    }
	    else {
		warn "bad episode number '$episode_num' "
		  . "in line from url $url: $_";
	    }
	}

	# Epsiode name.  This corresponds to the badly named
	# 'sub-title' in XMLTV.
	#
	if (length $episode_name) {
	    $p{'sub-title'} = [ [ $episode_name, $LANG ] ];
	}

	# Cast.
	if (length $cast) {
	    foreach (split /\s*,\s*/, $cast) {
		push @{$p{credits}{actor}}, $_;
	    }
	}

	# Director.
	if (length $director) {
	    foreach (split /\s*,\s*/, $director) {
		push @{$p{credits}{director}}, $_;
	    }
	}
	
	# Ananova's idea of 'duration' is usually the original length
	# of a film - not the length it is shown at on TV.  Now we do
	# have a 'length' element in the XMLTV format, but that's
	# meant for the length _as shown_, just not including adverts
	# or other junk.  So we just discard duration.
	#
	# FIXME there is an occasional bug where the duration has what
	# looks like a year stuck three times onto the end.  As in
	# '85 mins1997 1997 1997'.
	#
	$duration =~ s/(\d{4}) \1 \1$//;
	if ($duration ne '' and $duration !~ /^(\d+)\s+(?:mins|minutes)$/) {
	    warn "bad duration $duration "
	      . "in line from url $url: $_";
	}

	# Description.  Any special munging on this will happen later.
	if (length $desc) {
	    $p{desc} = [ [ $desc, $LANG ] ];
	}

	# Programme type.
	if (length $type) {
	    foreach (split /\s*,\s*/, $type) {
		# We don't give the language for categories because
		# they are liable to be strange strings like 'chldrn'.
		#
		push @{$p{category}}, [ lc $_ ];
	    }
	}

	# Subtitles.  Assume that when Ananova say this, they mean
	# teletext (I don't know what happens for foreign films with
	# on-screen subtitles).
	#
	if ($subtitled) {
	    # We don't know what language the subtitles are in.  $LANG
	    # sets the language for the descriptions, not the
	    # programmes themselves.
	    #
	    $p{subtitles} = [ { type => 'teletext' } ];
	}
	
	# Check 'type' of channel to decide whether video and audio
	# elements need be present.  If $p{video}{present} is false,
	# that means there's definitely no picture; if it's undefined
	# then we don't know yet.
	#
	my $ch_type = $ch_types->{$ch};
	if (not defined $ch_type) {
	    die "no channel type for channel $ch";
	}

	if ($ch_type =~ /\d$/) {
	    # Terrestrial television.  We can't infer anything from
	    # that, because occasionally programmes are broadcast with
	    # no picture or no sound.
	    #
	}
	elsif ($ch_type eq 'satellite') {
	    # Similar.
	}
	elsif ($ch_type eq 'radio') {
	    $p{video}{present} = 0;
	    $p{audio}{present} = 1;
	}
	else { die "bad type $ch_type for channel $ch" }

	# Black and white - in other words, not colour.
	if ($bw) {
	    if (defined $p{video}{present} and not $p{video}{present}) {
		warn "black-and-white flag set for a programme with no picture";
	    }
	    $p{video}{present} = 1;
	    $p{video}{colour} = 0;
	}
	
	# Stereo or mono.
	if (not $stereo and not $mono) {
	    # Just don't set any of the flags.
	}
	else {
	    if (defined $p{audio}{present} and not $p{audio}{present}) {
		warn "stereo information set for a programme with no sound";
	    }
	    $p{audio}{present} = 1;

	    if (not $stereo and $mono) {
		$p{audio}{stereo} = 'mono';
	    }
	    elsif ($stereo and not $mono) {
		$p{audio}{stereo} = 'stereo';
	    }
	    elsif ($stereo and $mono) {
		warn "line in page $url has both stereo and mono: $_";
	    }
	    else { die }
	}

	# Repeat or new.  I don't know whether these are necessarily
	# mutually exclusive - you might have an instant repeat of the
	# first episode of a new series have both.  So I won't bother
	# checking that both are not set.
	#
	if ($repeat) {
	    # 'Repeat' in British TV usually means 'previously shown
	    # on the same channel'.  It has happened that series
	    # transferred from one channel to another got repeated on
	    # the new channel as 'new'.
	    #
	    # However, we can't say this for sure.  Things can be
	    # shown on BBC1 and then 'repeated' on BBC2, for example.
	    # Short of some really ornate system to describe all
	    # different nuances of previously-shown in the file
	    # format, we just have to leave the element empty.
	    #
	    $p{'previously-shown'} = {};
	}
	if ($new) {
	    $p{new} = 1;
	}

	# I don't know what the 'digital' flag is for: Ananova says
	# 'if known to be available on as digital transmission'.  Just
	# ignore it.
	#

	# Finally there are four descriptions, with increasing levels
	# of detail.  It might be a good idea to extend the XMLTV
	# format to support several descriptions of differing length,
	# but for now we just sanity-check them.
	#
	my @descs = @fields[17..20];
	foreach my $i (0 .. $#descs) {
	    next if not defined $descs[$i] or not length $descs[$i];
	    foreach my $j ($i+1 .. $#descs) {
		next if not defined $descs[$j] or not length $descs[$j];
		# Sometimes the data really does have shorter text for
		# the supposedly more detailed description.  So we
		# can't check it pedantically.  OTOH this has caught
		# some errors in data input.  So we use a heuristic:
		# the more detailed description should be at least
		# half as long as a less detailed one.
		#
		if (2 * length $descs[$j] < length $descs[$i]) {
		    unless ($warned_shorter{$descs[$j]}{$descs[$i]}++) {
			warn
			  "description $j ($descs[$j]) is much shorter than description $i ($descs[$i]) "
			    . "in line from url $url: $_";
		    }
		}
	    }
	}
	# The most detailed description should be the same as the main
	# description.  Er, except when it is not present at all.
	#
	if (defined $descs[3] and $descs[3] ne '' and $descs[3] ne $desc) {
	    warn "description 3 ($descs[3]) isn't the same as main desc ($desc) "
	      . "in line from url $url: $_";
	}

	# Channel.  By now we should know the pretty name of the
	# channel, so we can call ch_output() to map Ananova id to
	# output channel id.  (The pretty name is occasionally used
	# to help with this.)
	#
	$p{channel} = ch_output($ch);

	# Source - used for debugging and written out only as a
	# comment in the output.
	#
	$p{source} = $file;

	push @r, \%p;
    }
    return \@r;
}


# date_programmes()
#
# Given a list of programme details (from extract_progs()) and the date
# of this listing, add proper time and date for each programme.  In UT.
#
# Parameters:
#   reference to list of programme details
#   date in Date::Manip format
#
# Modifies the list passed in, so that each programme no longer has
# {'time'} but has {'start'} instead.  If the programme has
# {'length'}, gets rid of that too and puts in {'stop'}.
#
sub date_programmes($$) {
#    local $Log::TraceMessages::On = 1;
    die 'usage: date_programmes(ref to list of programmes, date)'
      if @_ != 2;
    my ($progs, $base_date) = @_;
    t 'adding date to programmes: ' . d $progs;
    t 'base date: ' . d $base_date;
    my $base_day = UnixDate($base_date, '%Q');
    die if not defined $base_day;
    die 'bad base day, format should be YYYYMMDD'
      if $base_day !~ /^\d{8}$/;

    my $prev_date;
    my $day_later = ParseDateDelta('+1 day') or die;
    my $current_tz = 0; # not undef, because of Memoize complaining

    foreach (@$progs) {
	t('adding date to programme ' . d($_));
	my $t = $_->{'time'};
	
	# $t should be hours and minutes, add seconds
	$t =~ s/\b(\d\d):(\d\d)\b/$1:$2:00/ or die "bad hh:mm $t";

	if (defined gettz($t)) {
#	    local $Log::TraceMessages::On = 1;
	    t "found explicit timezone $t, using for future progs";
	    $current_tz = gettz($t);
	}

	t "doing 24h UK time $t with base day $base_day";
	my $prog_date = parse_uk_date("$base_day $t", $current_tz);
	if (not defined $prog_date) {
	    # It's not a valid UK time.  Two reasons for this: it
	    # really isn't, or we're just confused about what day it
	    # is and need to 'jump' forward a day.
	    #
	    t 'that date is bad, maybe need to jump a day?';
	    my $err;
	    my $new_base_day = UnixDate
	      DateCalc($base_day, $day_later, \$err),
	      '%Q';
	    die "error from DateCalc(): $err" if defined $err;
	    my $new_prog_date = parse_uk_date("$new_base_day $t", $current_tz);
	    die "bad base day + time '$t' (even tried next day)"
	      if (not defined $new_prog_date) or ($new_prog_date !~ /\S/);
	    t 'okay... assume we will jump a day (do it later)';
	}

	if ((not defined $prog_date)
	    or (defined $prev_date
		and (Date_Cmp($prev_date, $prog_date) > 0) ) )
        {
	    # Seem to have jumped backwards in time.  Must be the next
	    # day - but see below.
	    #
	    t 'time is lower than before';
	    my $prev_day = UnixDate $prev_date, '%Q';
	    t 'previous programme was at ' . d($prev_date);
	    my $threshold = ParseDate("$prev_day 12:00:00");
	    t 'threshold is ' . d($threshold);
	    if (Date_Cmp($prev_date, $threshold) < 0) {
		# I can't believe that one programme would last from
		# before 12:00 until after midnight on any day.  So
		# this seeming jump to the next day is bogus - it's
		# the same day but the time is a little bit earlier
		# for some reason.  (Probably UT/BST switching)
		#
		t 'previous programme started before threshold, ' .
		  'cannot be next day';
	    }
	    else {
		t 'must be next day';
		my $err;
		$base_day = UnixDate
		  DateCalc($base_day, $day_later, \$err),
		  '%Q';
		die "error from DateCalc(): $err" if defined $err;
		$prog_date = parse_uk_date("$base_day $t", $current_tz);
		die "bad base day + time '$t'"
		  if (not defined $prog_date) or ($prog_date !~ /\S/);
		t 'new base day: ' . d($base_day);
	    }
	}

	delete $_->{'time'};
	$_->{'start'} = $prog_date;
	t 'new start time: ' . d($_->{start});
	$prev_date = $prog_date;

	if (defined(my $length = delete $_->{length})) {
	    # Try to calculate the stop time based on start time and length.
	    if (not defined $_->{stop}) {
		my $stop = DateCalc($_->{start}, "+ $length");
		if (defined $stop) {
		    $_->{stop} = $stop;
		}
		else {
		    warn "could not calculate stop time from $_->{start} + $length";
		}
	    }
	    else {
		warn 'programme has both length and stop';
	    }
	}
    }
}


# add_clumpidx()
#
# Sometimes two programmes on a channel are given the same
# start time in the listings.  This seems to happen when the
# first is a 'mothership' containing several smaller things,
# for example '11:00 The Core, 11:00 Core News'.
#
# We add a 'clumpidx' attribute to distinguish these
# programmes.  Eg 'The Core' has clumpidx '0/2' and 'Core
# News' has '1/2'.
#
# Parameters:
#   a reference to a list of programmes for one channel, which will
#   be modified
#
sub add_clumpidx($) {
    die "usage: add_clumpidx(ref to list of programmes)"
      if @_ != 1;
    my $progs = shift;
    t('add_clumpidx() ENTRY');

    my $last_start;
    my %num_in_clump; # Maps start time to num. progs at that time
    foreach (@$progs) {
	t 'looking at programme: ' . d($_);
	my $start = $_->{start};
	t '$start=' . d($start);
	$_->{clumpidx} = $num_in_clump{$start}++;
	t 'clumpidx now ' . d($_->{clumpidx});

	if ($num_in_clump{$start} > 1) {
	    if (not defined $last_start or $last_start ne $start) {
		warn <<END
more than one programme at $start on same channel, \
but not consecutive in listings (this is $_->{title})
END
				 ;
	    }
	}
	$last_start = $start;
    }

    # Okay, we've got clumpidx of '0', '1' where needed, but even
    # better would be '0/2', '1/2'.  We look at how many programmes
    # are in each clump: if only one, remove the clumpidx entirely.
    # If more than one, put the full 'x/y' clumpidx.
    #
    t "refine clumpidx's and build todo list";
    my %todo;
    foreach (@$progs) {
	t 'looking at programme: ' . d($_);
	my $start = $_->{start};
	my $num = $num_in_clump{$start};
	die if not defined $_->{clumpidx};
	if ($num == 1) {
	    # Ordinary, sane programme not sharing its slot.  This
	    # would have a clumpidx of '0/1', which isn't worth
	    # putting in the output.
	    #
	    t 'only programme in slot';
	    die if $_->{clumpidx} ne '0';
	    delete $_->{clumpidx};
	}
	elsif ($num > 1) {
	    t 'shares a slot';
	    $_->{clumpidx} .= "/$num";
	    t 'new clumpidx: ' . d($_->{clumpidx});
	    push @{$todo{$start}}, $_;
	    t "\$todo{$start} now " . d($todo{$start});
	}
	else { die }
    }
    t 'add_clumpidx() EXIT';
}

####
# Channels stuff
#

# Convert the channels data into a suitable form for output.  Uses the
# following globals:
#
# %$ch_pretty - Ananova id to pretty name
# %output_to_number - XMLTV channel id to additional pretty name
# Calls ch_output() to turn Ananova id into XMLTV id.
#
# Also info on channel types for sanity checking, but that's not
# really important.
#
# FIXME these three different lookups really need to be more
# consistent.
#
sub channels_output() {
    t 'channels_output() ENTRY';
    my %channels_output;
	
    # Routine to modify %channels_output adding a new pretty name for
    # an internal channel id.
    #
    my $add_to_output = sub( $ ) {
		my ($id, $entry) = @_;
		t "asked to add pretty name '$entry' to channel id $id";
		# Don't want to add it if it's already in the list.
		my $already = 0;
		foreach (@{$channels_output{$id}}) {
	    	t 'checking existing entry: ' . d $_;
	    	next if $_->[0] ne $entry->[0];
	    	if (not defined $_->[1] and not defined $entry->[1]) {
				$already = 1;
				last;
	    	}
	    	if (defined $_->[1] and defined $entry->[1]
					and $_->[1] eq $entry->[1]) {
				$already = 1;
				last;
	    	}
		}
		t "already in there? $already";
		unless ($already) {
	    	push @{$channels_output{$id}}, $entry;
	    	t 'list now: ' . d $channels_output{$id};
		}
    };
	
    foreach (keys %$ch_pretty) {
		next unless $want_all or $wanted_type{$ch_types->{$_}} or $wanted_ch{$_};
		my $o = ch_output($_);
		my $p = $ch_pretty->{$_}; die if not defined $p;

		# Don't need to warn about more than one channel with the same
		# output id, because Channel 4 and Channel 5 are considered by
		# Ananova as split into regions, but each region is in fact
		# the same.  Likewise some things like the two versions of
		# Meridian (different for BBC, but not ITV).
		#
		$add_to_output->($o, [ $p, $LANG ]);
    }
    foreach (keys %channels_output) {
		my $extra = $output_to_number{$_};
		if (defined $extra) {
	    	if ($extra =~ tr/0-9//c) {
				# Not a channel number, should have a 'language'.
				$add_to_output->($_, [ $extra, $LANG ]);
	    	} else {
				$add_to_output->($_, [ $extra ]);
	    	}
		}
    }
    t 'channels_output() RETURNING ' . d \%channels_output;
    return \%channels_output;
}


# Given an Ananova internal channel id, return the output
# RFC2838-style name.  Where the name is not known, we invent one
# based on ananova.com (using global $ch_pretty).
#
# Parameter: Ananova internal channel identifier
# Returns: funky domain name type string
#
my $ch_to_output; # cache, initialized with some hardcoded names
sub ch_output($) {
    local $Log::TraceMessages::On = 0;
    my $ch = shift;

    $ch_to_output = get_ch_to_output() if not defined $ch_to_output;
    if (not defined $ch_to_output->{$ch}) {
	my $pretty = $ch_pretty->{$ch};
	$pretty = $ch if not defined $pretty;
	my $munged = $pretty;
	for ($munged) {
	    t d $_;
	    tr/ _/-/s;
	    t d $_;
	    tr/a-zA-Z0-9-//cd;
	    t d $_;
	    tr/A-Z/a-z/;
	    t d $_;
	}
	my $new = "$munged.tv-listings.ananova.com";
	warn "don't know RFC2838-style name for $pretty ($ch), using $new\n";
	$ch_to_output->{$ch} = $new;
    }
    return $ch_to_output->{$ch};
}

# Return the list of what internal Ananova channel names map to what
# XMLTV internal channel names.  This isn't fetched from the site,
# it's just hardcoded here.
#
# The hash returned by this subroutine is just a starting point for
# ch_output(), which may make up new names for stations not mentioned.
#
# This function is just a place to store the big hash below; it is
# called only by ch_output() and get_channel_pkgs().
#
sub get_ch_to_output() {
    # It can be hard to decide whether two related channels should map
    # to the same internal name - eg digital and analogue versions of
    # the same channel.  I have made different internal names if I
    # know that the content will be different (eg BBC1 digital is
    # different to any of the analogue region versions), but otherwise
    # mapped both channels to the same internal name.  Sometimes there
    # are annoying small differences which require differing internal
    # names, else sort_listings complains.  The same applies to
    # regional variants for channels which don't differ between
    # regions (eg Channel 5).
    #
    # FIXME: There should be some code to make sure that if two sets
    # of listings for the same channel id are downloaded, they match
    # exactly.
    #
    my %ch_to_output =
      ('adult' => 'theadultchannel.co.uk', # Adult Channel
       'adultsonly1' => 'adults-only-1.itv.co.uk', # Adults Only 1
       'adultsonly2' => 'adults-only-2.itv.co.uk', # Adults Only 2
       'anglia_0' => 'anglia.tv.co.uk', # Anglia
       'animalplanetdigital' => 'animalplanet.discoveryeurope.com', # Animal Planet (Digital)
       'asianet' => 'asianet-tv.com', # Asia.net
       'atlantic252' => 'atlantic252.com', # Atlantic 252
       'bbc1_2' => 'south-east.bbc1.bbc.co.uk', # BBC1
       'bbc1digital' => 'digital.bbc1.bbc.co.uk', # BBC1 (Digital)
       'bbc1ea_0' => 'east.bbc1.bbc.co.uk', # BBC1 East Anglia
       'bbc1irish_12' => 'ireland.bbc1.bbc.co.uk', # BBC1 Ireland
       'bbc1irishdigital' => 'digital.ireland.bbc1.bbc.co.uk', # BBC1 Ireland (Digital)
       'bbc1london_16' => 'london.bbc1.bbc.co.uk', # BBC1 LONDON
       'bbc1mid_3' => 'midlands.bbc1.bbc.co.uk', # BBC1 Midlands
       'bbc1n_14' => 'north.bbc1.bbc.co.uk', # BBC1 North
       'bbc1ne_1' => 'north-east.bbc1.bbc.co.uk', # BBC1 North East
       'bbc1ne_11' => 'north-east.bbc1.bbc.co.uk', # BBC1 North East
       'bbc1nw_6' => 'north-west.bbc1.bbc.co.uk', # BBC1 North West
       'bbc1s_9' => 'south.bbc1.bbc.co.uk', # BBC1 South
       'bbc1scot_10' => 'scotland.bbc1.bbc.co.uk', # BBC1 Scotland
       'bbc1scot_17' => 'scotland.bbc1.bbc.co.uk', # BBC1 Scotland
       'bbc1scot_5' => 'scotland.bbc1.bbc.co.uk', # BBC1 Scotland
       'bbc1scotdigital' => 'digital.scotland.bbc1.bbc.co.uk', # BBC1 Scotland (Digital)
       'bbc1se_15' => 'south-east.bbc1.bbc.co.uk', # BBC1 South East
       'bbc1sw_13' => 'south-west.bbc1.bbc.co.uk', # BBC1 South West
       'bbc1sw_4' => 'south-west.bbc1.bbc.co.uk', # BBC1 South West
       'bbc1w_8' => 'west.bbc1.bbc.co.uk', # BBC1 West
       'bbc1walesdigital' => 'digital.wales.bbc.co.uk', # BBC1 Wales (Digital)
       'bbc1wales_7' => 'wales.bbc1.bbc.co.uk', # BBC1 Wales
       'bbc2_2' => 'south-east.bbc2.bbc.co.uk', # BBC2
       'bbc2digital' => 'digital.bbc2.bbc.co.uk', # BBC2 (Digital)
       'bbc2ea_0' => 'east.bbc2.bbc.co.uk', # BBC2 East Anglia
       'bbc2irish_12' => 'ireland.bbc2.bbc.co.uk', # BBC2 Ireland
       'bbc2irishdigital' => 'digital.ireland.bbc2.bbc.co.uk', # BBC2 Ireland (Digital)
       'bbc2mid_3' => 'midlands.bbc2.bbc.co.uk', # BBC2 Midlands
       'bbc2n_14' => 'north.bbc2.bbc.co.uk', # BBC2 North
       'bbc2ne_1' => 'north-east.bbc2.bbc.co.uk', # BBC2 North East
       'bbc2ne_11' => 'north-east.bbc2.bbc.co.uk', # BBC2 North East
       'bbc2nw_6' => 'north-west.bbc2.bbc.co.uk', # BBC2 North West
       'bbc2s_9' => 'south.bbc2.bbc.co.uk', # BBC2 South
       'bbc2scot_10' => 'scotland.bbc2.bbc.co.uk', # BBC2 Scotland
       'bbc2scot_17' => 'scotland.bbc2.bbc.co.uk', # BBC2 Scotland
       'bbc2scot_5' => 'scotland.bbc2.bbc.co.uk', # BBC2 Scotland
       'bbc2scotdigital' => 'digital.scotland.bbc2.bbc.co.uk', # BBC2 Scotland (Digital)
       'bbc2se_15' => 'south-east.bbc2.bbc.co.uk', # BBC2 South East
       'bbc2sw_13' => 'south-west.bbc2.bbc.co.uk', # BBC2 South West
       'bbc2sw_4' => 'south-west.bbc2.bbc.co.uk', # BBC2 South West
       'bbc2w_8' => 'west.bbc2.bbc.co.uk', # BBC2 West
       'bbc2wales_7' => 'wales.bbc2.bbc.co.uk', # BBC2 Wales
       'bbc2walesdigital' => 'digital.wales.bbc2.bbc.co.uk', # BBC2 Wales (Digital)
       'bbcchoice' => 'choice.bbc.co.uk', # BBC Choice
       'bbcknowledge' => 'knowledge.bbc.co.uk', # BBC Knowledge
       'bbcnews24' => 'news-24.bbc.co.uk', # BBC News 24
       'bbcparliament' => 'parliament.bbc.co.uk', # BBC Parliament
       # Just for fun we'll use the Boston Business
       # Consulting domain for the international (rather
       # than British) BBC channels.
       #
       'bbcprime' => 'prime.bbc.com', # BBC Prime
       'bbcworld' => 'world-tv.bbc.com', # BBC World
       'bloomberg' => 'bloomberg.com', # Bloomberg TV
       'border_1' => 'border-tv.com', # Border
       'bordern_17' => 'border-tv.com', # Border (Scottish viewers).  FIXME
       # FIXME can't find domain name for 'Box'
       'box' => 'box.tv-listings.ananova.com',
       'bravodigital' => 'bravo.co.uk', # Bravo (Digital)
       'britisheurosport' => 'british.eurosport.com', # British Eurosport
       'bsb_movie' => 'sky-premier.sky.com', # Sky Premier
       'bsb_sports' => 'sky-sports-1.sky.com', # yes, really
       'carlton_16' => 'carlton.com', # Carlton
       'carlton_2' => 'carlton.com', # Carlton
       'carltoncinema' => 'cinema.carlton.com', # Carlton Cinema
       'carltonfood' => 'food.carlton.com', # Taste CFN
       'cartoon' => 'uk.cartoonnetwork.com', # Cartoon Network
       'central_3' => 'central.carlton.com', # Central
       'ch4_0' => 'channel4.com', # Channel 4
       'ch4_1' => 'channel4.com', # Channel 4
       'ch4_10' => 'channel4.com', # Channel 4
       'ch4_11' => 'channel4.com', # Channel 4
       'ch4_12' => 'channel4.com', # Channel 4
       'ch4_13' => 'channel4.com', # Channel 4
       'ch4_14' => 'channel4.com', # Channel 4
       'ch4_15' => 'channel4.com', # Channel 4
       'ch4_16' => 'channel4.com', # Channel 4
       'ch4_17' => 'channel4.com', # Channel 4
       'ch4_2' => 'channel4.com', # Channel 4
       'ch4_3' => 'channel4.com', # Channel 4
       'ch4_4' => 'channel4.com', # Channel 4
       'ch4_5' => 'channel4.com', # Channel 4
       'ch4_6' => 'channel4.com', # Channel 4
       'ch4_7' => 'channel4.com', # Channel 4
       'ch4_8' => 'channel4.com', # Channel 4
       'ch4_9' => 'channel4.com', # Channel 4
       'ch5_0' => 'channel5.co.uk', # Channel 5
       'ch5_1' => 'channel5.co.uk', # Channel 5
       'ch5_10' => 'channel5.co.uk', # Channel 5
       'ch5_11' => 'channel5.co.uk', # Channel 5
       'ch5_12' => 'channel5.co.uk', # Channel 5
       'ch5_13' => 'channel5.co.uk', # Channel 5
       'ch5_14' => 'channel5.co.uk', # Channel 5
       'ch5_15' => 'channel5.co.uk', # Channel 5
       'ch5_16' => 'channel5.co.uk', # Channel 5
       'ch5_17' => 'channel5.co.uk', # Channel 5
       'ch5_2' => 'channel5.co.uk', # Channel 5
       'ch5_3' => 'channel5.co.uk', # Channel 5
       'ch5_4' => 'channel5.co.uk', # Channel 5
       'ch5_5' => 'channel5.co.uk', # Channel 5
       'ch5_6' => 'channel5.co.uk', # Channel 5
       'ch5_7' => 'channel5.co.uk', # Channel 5
       'ch5_8' => 'channel5.co.uk', # Channel 5
       'ch5_9' => 'channel5.co.uk', # Channel 5
       # FIXME: Ananova calls this 'Channel Islands'
       'channel_4' => 'channel-islands.tv-listings.ananova.com',
       'christian' => 'christian-channel-europe.god-digital.com', # God Channel
       'classicfm' => 'classicfm.co.uk', # Classic FM
       'cnbc' => 'europe.cnbc.com', # CNBC Europe
       'cnn' => 'europe.cnn.com', # CNN
       # FIXME cannot find domain for '.tv' - how do you type that into Google?
       'computer' => 'dot-tv.tv-listings.ananova.com',
       'cymru' => 'radio-cymru.bbc.co.uk', # Radio Cymru
       'digitalclassicstv' => 'digitalclassics.tv', # Digital Classics TV
       'discoverycivilisations' => 'civilisations.discoveryeurope.com', # Discovery Civilisations
       'discoverydigital' => 'discoveryeurope.com', # Discovery (Digital)
       'discoverykids' => 'kids.discoveryeurope.com', # Discovery Kids
       # Maybe 'Plus 1' means timewarped
       # by one hour.  There needs to be
       # some convention for that.
       'discoveryplus1' => 'plus-1.discoveryeurope.com', # Discovery Plus 1
       'discoveryscitrek' => 'sci-trek.discoveryeurope.com', # Discovery Sci Trek
       'discoverytravel' => 'travel.discoveryeurope.com', # Discovery Travel & Adventure
       'discoverywings' => 'wings.discoveryeurope.com', # Discovery Wings
       'disney' => 'disneychannel.disney.co.uk', # The Disney Channel
       'e4' => 'e4.channel4.com', # E4
       'einsteintv' => 'einstein.tv', # Einstein TV
       'extremesports' => 'extreme.com', # Extreme Sports
       'family_channeldigital' => 'challengetv.co.uk', # Challenge TV (Digital)
       'fantasy' => 'fantasy.televisionx.co.uk', # Fantasy Channel
       'fashiontv' => 'ftv.com', # Fashion TV
       'filmfour' => 'filmfour.channel4.com', # Film on Four
       'filmfourextreme' => 'extreme.filmfour.channel4.com', # FilmFour Extreme
       'filmfourplus1' => 'plus-1.filmfour.channel4.com', # FilmFour+1
       'filmfourworld' => 'world.filmfour.channel4.com', # FilmFour World
       'foxdigital' => 'foxkids.co.uk', # Fox Kids Network (Digital)
       'foxplus1' => 'plus-1.foxkids.co.uk', # Fox Kids Plus 1
       'grampian_5' => 'grampiantv.co.uk', # Grampian
       'granada_6' => 'granadatv.co.uk', # Granada (site down ATM)
       'granada_breezeondigital' => 'breeze.granadatv.co.uk', # Granada Breeze
       'granada_men' => 'men.granadatv.co.uk', # Granada Men & Motors
       'granada_menondigital' => 'itv-digital.men.granadatv.co.uk', # Granada Men & Motors - ITV Digital
       'granada_plus' => 'plus.granadatv.co.uk', # Granada Plus
       'granada_plusondigital' => 'plus.granadatv.co.uk', # Granada Plus - ITV Digital
       'historydigital' => 'thehistorychannel.co.uk', # History Channel (Digital)
       'htvwales_7' => 'wales.htv.co.uk', # HTV Wales
       'htvwest_8' => 'west.htv.co.uk', # HTV West
       'itv2' => 'itv2.itv.co.uk', # ITV2
       'itvsport' => 'sport.itv.co.uk', # ITV Sport
       'itvsportplus' => 'sport-plus.itv.co.uk', # ITV Sport
       'itvsportselect' => 'sport-select.itv.co.uk', # ITV Sport Select
       'landscape' => 'landscapetv.com', # Landscape Channel
       'london_live' => 'london-live.bbc.co.uk', # BBC London Live
       'm2' => 'm2europe.com',	# M2
       'meridian_15' => 'meridian.tv.co.uk', # Meridian
       'meridian_9' => 'meridian.tv.co.uk', # Meridian
       'mtv' => 'mtv.co.uk',	# MTV
       'mtvbase' => 'base.mtv.co.uk', # MTV Base
       'mtvdance' => 'dance.mtv.co.uk', # MTV Dance
       'mtvextra' => 'hits.mtv.co.uk', # MTV Hits
       # musicchoice.co.uk is down
       'musicchoiceblues' => 'blues.musicchoice.co.uk', # Music Choice Blues
       'musicchoiceclassical' => 'classical.musicchoice.co.uk', # Music Choice Classical
       'musicchoicecountry' => 'country.musicchoice.co.uk', # Music Choice Country
       'musicchoicedance' => 'dance.musicchoice.co.uk', # Music Choice Dance
       'musicchoiceeasy' => 'easy.musicchoice.co.uk', # Music Choice Easy
       'musicchoicegold' => 'gold.musicchoice.co.uk', # Music Choice Gold
       'musicchoicehits' => 'hits.musicchoice.co.uk', # Music Choice Hits
       'musicchoicejazz' => 'jazz.musicchoice.co.uk', # Music Choice Jazz
       'musicchoicelove' => 'love.musicchoice.co.uk', # Music Choice Love
       'musicchoicerock' => 'rock.musicchoice.co.uk', # Music Choice Rock
       'mutv' => 'mutv.manutd.com', # MUTV
       'nagaeltachta' => 'rnag.ie', # Radio na Gaeltachta
       'nationalgeographicdigital' => 'nationalgeographic.co.uk', # National Geographic (Digital)
       'nickelodeon' => 'nickelodeon.co.uk', # Nickelodeon
       'nickelodeondigital' => 'nickelodeon.co.uk', # Nickelodeon (Digital)
       'nickelodeonddigital' => 'nickelodeon.co.uk', # Nickelodeon (Digital)
       'nickelodeonjr' => 'jr.nickelodeon.co.uk', # Nickelodeon Jr
       'nickelodeonreplay' => 'replay.nickelodeon.co.uk', # Nickelodeon Replay
       'paramount' => 'paramountcomedy.com', # Paramount Comedy
       'performance' => 'performancetv.co.uk', # Performance
       'performancedigital' => 'digital.performancetv.co.uk', # Performance (Digital)
       'playboy' => 'playboy.com', # Playboy Channel
       'qvc' => 'qvcuk.com',	# QVC
       'racing' => 'racingchannel.com', # The Racing Channel
       'radio1' => 'radio-1.bbc.co.uk',
       'radio2' => 'radio-2.bbc.co.uk',
       'radio3' => 'radio-3.bbc.co.uk',
       'radio4' => 'radio-4.bbc.co.uk',
       'radio5mw' => 'radio-5-mw.bbc.co.uk',
       # Ananova internal name wrong
       'radioireland' => 'todayfm.com', # Today FM
       'radioscotland' => 'radio-scotland.bbc.co.uk', # Radio Scotland
       'radioulster' => 'radio-ulster.bbc.co.uk', # Radio Ulster
       # Couldn't find a domain name for Red Hot All Girl
       'redhotallgirl' => 'red-hot-all-girl.tv-listings.ananova.com', # Red Hot All Girl
       'rte1_12' => 'rte-1.rte.ie', # RTE 1
       'rte2_12' => 'rte-2.rte.ie', # RTE 2
       'rteradio1' => 'radio-1.rte.ie', # RTE Radio 1
       'rteradio2' => '2-fm.rte.ie', # 2 FM
       'rteradiofm3' => 'lyric-fm.rte.ie', # Lyric FM
       's4c_7' => 's4c.co.uk',	# S4C (Welsh Channel 4)
       's4cdigital' => 'digital.s4c.co.uk', # Channel 4 - Wales (Digital)
       'scificable' => 'cable.uk.scifi.com', # Sci-Fi (Cable)
       'scifidigital' => 'digital.uk.scifi.com', # Sci-Fi (Digital)
       'scottish_10' => 'scottishtv.co.uk', # Scottish
       'shop' => 'shop-tv.co.uk', # Shop!
       'simplyshopping' => 'simplyshoppingtv.co.uk', # Simply Shopping
       'sky_boxofficedigital' => 'box-office-digital.sky.com', # Sky Box Office Digital
       'sky_channel' => 'sky-one.sky.com', # Sky One
       'sky_eurosport' => 'eurosport.sky.com', # Eurosport
       'sky_moviemax2' => '2.moviemax.sky.com', # Sky Moviemax 2
       'sky_moviemax3' => '3.moviemax.sky.com', # Sky Moviemax 3
       'sky_moviemax4' => '4.moviemax.sky.com', # Sky Moviemax 4
       'sky_moviemax5' => '5.moviemax.sky.com', # Sky Moviemax 5
       'sky_moviemaxondigital' => 'itvdigital.moviemax.sky.com', # Sky Moviemax - Ondigital
       'sky_movies' => 'moviemax.sky.com', # Sky Moviemax
       'sky_moviesgolddigital' => 'cinema.sky.com', # Sky Cinema (Digital)
       'sky_news' => 'sky-news.sky.com', # Sky News
       'sky_oneondigital' => 'ondigital.sky-one.sky.com', # Sky One (Ondigital)
       'sky_premier2' => '2.premier.sky.com', # Sky Premier 2
       'sky_premier3' => '3.premier.sky.com', # Sky Premier 3
       'sky_premier4' => '4.premier.sky.com', # Sky Premier 4
       'sky_premierondigital' => 'ondigital.premier.sky.com', # Sky Premier - Ondigital
       'sky_premierwidescreen' => 'widescreen.premier.sky.com', # Sky Premier - Widescreen
       'sky_sports2' => '2.sports.sky.com', # Sky Sports 2
       'sky_sports3' => '3.sports.sky.com', # Sky Sports 3
       'sky_sportsnews' => 'news.sports.sky.com', # Sky Sports.comTV
       'skycinema2' => '2.cinema.sky.com', # Sky Cinema 2
       'sonytv' => 'setindia.com', # Sony Entertainment TV Asia
       # Couldn't find domain name for Shop America
       'st121' => 'shop-america.tv-listings.ananova.com', # Shop America
       'st179' => '51.front-row.ntl.com', # Front Row 51
       'st180' => '52.front-row.ntl.com', # Front Row 52
       'st181' => '53.front-row.ntl.com', # Front Row 53
       'st182' => '54.front-row.ntl.com', # Front Row 54
       # Assuming Health Channel is this and not Discovery's
       'st200' => 'channelhealth.tv', # Health Channel
       'st214' => 'front-row.ntl.com', # Front Row Digital
       'st215' => 'boomerang.cartoonnetwork.com', # Boomerang
       'st216' => 'qvc1.qvcuk.com', # QVC1
       'st417' => 'toon.disney.co.uk', # Toon Disney
       'st418' => 'playhouse.disney.co.uk', # Playhouse Disney
       'st422' => '2.tvtravelshop.co.uk', # TV Travel Shop 2
       'st432' => '1.sports.sky.com', # Sky Sports 1 (ITV Digital)
       'st436' => '3.sports.sky.com', # Sky Sports 3 (ITV Digital)
       'st437' => 'extra.sports.sky.com', # Sky Sports Extra
       'st438' => '2.sports.sky.com', # Sky Sports 2 (ITV Digital)
       'st474' => 'biography-channel.biography.com', # Biography Channel
       # Something like 'Channel 9' is hard to search for...
       'st500' => 'channel-9.tv-listings.ananova.com', # Channel 9 Television
       'st58' => 'beti.tv', # BET International
       'st602' => 'artsworld.com', # Artsworld
       'st606' => 'studio.com', # Studio
       'st612' => 'asia1tv.com', # Asia1 TV
       'st613' => 'banglatv.com', # Bangla TV
       'st615' => 'screenshop.co.uk', # Screenshop
       'st616' => 'itn.co.uk', # ITN News Channel
       # pakistanichannel.com is currently down
       'st617' => 'pakistanichannel.com', # Pakistani Channel
       'st619' => 'b4utv.com', # B4U Movies
       # Landmark Travel Channel appears not to have a domain
       'st66' => 'landmark-travel.tv-listings.ananova.com', # Landmark Travel
       'st678' => 'star-plus.startv.com', # Star Plus
       'st701' => 'plus-1.home.discoveryeurope.com', # Discovery Home & Leisure Plus 1
       'st702' => 'plus-1.thehistorychannel.co.uk', # History Channel Plus 1
       'st705' => 'plus-1.uk.cartoonnetwork.com', # Cartoon Network Plus 1
       'st707' => 'plus-1.disneychannel.disney.co.uk', # Disney Plus 1
       'talkradiouk' => 'talk-radio.co.uk', # Talk Sport, apparently
       'tara' => 'taratv.net',	# TARA
       'tcm' => 'tcm.turner.com', # TCM (Digital)
       'tlcdigital' => 'home.discoveryeurope.com', # Discovery Home & Leisure (Digital)
       'traveldigital' => 'travelchannel.co.uk', # The Travel Channel (Digital)
       'troubledigital' => 'trouble.co.uk', # Trouble (Digital)
       'tv452' => 'utv2.utv.co.uk', # UTV2
       'tv83' => 'tg4.ie', # TG4
       'tv84' => 'tv3.ie', # TV3
       'tv_724_16' => 'london.bbc2.bbc.co.uk', # BBC2 London
       'tvasia' => 'tvasia.com', # ZEE TV (maybe not right)
       'tvtravelshop' => 'tvtravelshop.co.uk', # TV Travel Shop
       'tyne_11' => 'tttv.granadatv.co.uk', # North East
       'ukarena' => 'uk-drama.flextech.telewest.co.uk', # UK Drama
       'ukgold' => 'uk-gold.flextech.telewest.co.uk', # UK Gold
       'ukgoldclassics' => 'uk-gold-2.flextech.telewest.co.uk', # UK Gold 2
       'ukhorizons' => 'uk-horizons.flextech.telewest.co.uk', # UK Horizons
       'ukliving' => 'living.flextech.telewest.co.uk', # Living
       'ukplay' => 'play.flextech.telewest.co.uk', # Play UK
       'ukstyle' => 'uk-style.flextech.telewest.co.uk', # UK Style
       'ulster_12' => 'utv.co.uk', # Ulster
       'vh1' => 'vh1online.co.uk', # VH1
       'vh1classic' => 'classic.vh1online.co.uk', # VH1 Classic
       'virgin' => 'virginradio.co.uk', # Virgin
       'wales' => 'radio-wales.bbc.co.uk', # Radio Wales
       'wellbeing' => 'wellbeing.com', # Wellbeing
       'westcountry_13' => 'westcountry.carlton.com', # West Country
       'worldsvc' => 'world-svc.bbc.com', # World Service
       'ytv_14' => 'yorkshire.granadatv.co.uk', # Yorkshire
      );
    return \%ch_to_output;
}

# Return a hash mapping internal name to channel number (really just
# an extra pretty name).
#
sub get_output_to_number() {
    my %channel_numbers = ('theadultchannel.co.uk' => 'Adult',
			   'anglia.tv.co.uk' => 3,
			   'south-east.bbc1.bbc.co.uk' => 1,
			   'east.bbc1.bbc.co.uk' => 1,
			   'ireland.bbc1.bbc.co.uk' => 1,
			   'midlands.bbc1.bbc.co.uk' => 1,
			   'north.bbc1.bbc.co.uk' => 1,
			   'north-east.bbc1.bbc.co.uk' => 1,
			   'north-east.bbc1.bbc.co.uk' => 1,
			   'north-west.bbc1.bbc.co.uk' => 1,
			   'south.bbc1.bbc.co.uk' => 1,
			   'scotland.bbc1.bbc.co.uk' => 1,
			   'scotland.bbc1.bbc.co.uk' => 1,
			   'south-east.bbc1.bbc.co.uk' => 1,
			   'south-west.bbc1.bbc.co.uk' => 1,
			   'south-west.bbc1.bbc.co.uk' => 1,
			   'west.bbc1.bbc.co.uk' => 1,
			   'wales.bbc1.bbc.co.uk' => 1,
			   'digital.bbc1.bbc.co.uk' => 1,
			   'south-east.bbc2.bbc.co.uk' => 2,
			   'east.bbc2.bbc.co.uk' => 2,
			   'ireland.bbc2.bbc.co.uk' => 2,
			   'midlands.bbc2.bbc.co.uk' => 2,
			   'north.bbc2.bbc.co.uk' => 2,
			   'north-east.bbc2.bbc.co.uk' => 2,
			   'north-east.bbc2.bbc.co.uk' => 2,
			   'north-west.bbc2.bbc.co.uk' => 2,
			   'south.bbc2.bbc.co.uk' => 2,
			   'scotland.bbc2.bbc.co.uk' => 2,
			   'scotland.bbc2.bbc.co.uk' => 2,
			   'south-east.bbc2.bbc.co.uk' => 2,
			   'south-west.bbc2.bbc.co.uk' => 2,
			   'south-west.bbc2.bbc.co.uk' => 2,
			   'west.bbc2.bbc.co.uk' => 2,
			   'wales.bbc2.bbc.co.uk' => 2,
			   'digital.bbc2.bbc.co.uk' => 2,
			   'bloomberg.com' => 'Bloomberg',
			   'border-tv.com' => 3,
			   'bravo.co.uk' => 'Bravo',
			   'british.eurosport.com' => 'Eurosport',
			   'carlton.com' => 3,
			   'central.carlton.com' => 3,
			   'channel4.com' => 4, 
			   'channel5.co.uk' => 5,
			   'christian-channel-europe.god-digital.com'
		           => 'Christian',
			   'europe.cnbc.com' => 'CNBC',
			   'discoveryeurope.com' => 'Discovery',
			   'plus-1.discoveryeurope.com' => 'Discovery+1',
			   'sci-trek.discoveryeurope.com' => 'Sci-Trek',
			   'disneychannel.disney.co.uk' => 'Disney',
			   'challengetv.co.uk' => 'Challenge',
			   'fantasy.televisionx.co.uk' => 'Fantasy',
			   'filmfour.channel4.com' => 'FilmFour',
			   'foxkids.co.uk' => 'Fox Kids',
			   'plus-1.foxkids.co.uk' => 'Fox Kids+1',
			   'grampiantv.co.uk' => 3,
			   'granadatv.co.uk' => 3, 
			   'breeze.granadatv.co.uk' => 'Breeze',
			   'men.granadatv.co.uk' => 'Men & Motors',
			   'thehistorychannel.co.uk' => 'History',
			   'wales.htv.co.uk' => 3,
			   'west.htv.co.uk' => 3,
			   'sport-plus.itv.co.uk' => 'ITV Sport Plus',
			   'landscapetv.com' => 'Landscape',
			   'meridian.tv.co.uk' => 3,
			   'nationalgeographic.co.uk' => 'National Geographic',
			   'playboy.com' => 'Playboy',
			   'racingchannel.com' => 'Racing',
			   'radio-1.bbc.co.uk' => 'R1',
			   'radio-2.bbc.co.uk' => 'R2',
			   'radio-3.bbc.co.uk' => 'R3',
			   'radio-4.bbc.co.uk' => 'R4',
			   'radio-5-mw.bbc.co.uk' => 'R5',
			   's4c.co.uk' => 'S4C',
			   'digital.s4c.co.uk' => 'S4C',
			   'cable.uk.scifi.com' => 'Sci-Fi',
			   'digital.uk.scifi.com' => 'Sci-Fi',
			   'scottishtv.co.uk' => 3,
			   'shop-tv.co.uk' => 'Shop',
			   'box-office-digital.sky.com' => 'Sky Box Office',
			   'sky-one.sky.com' => 'S1', 
			   'eurosport.sky.com' => 'Eurosport',
			   'itvdigital.moviemax.sky.com' => 'Sky Moviemax',
			   'cinema.sky.com' => 'Sky Cinema',
			   'ondigital.sky-one.sky.com' => 'S1',
			   'ondigital.premier.sky.com' => 'Sky Premier',
			   'widescreen.premier.sky.com' => 'Sky Premier',
			   'setindia.com' => 'SETI',
			   'tcm.turner.com' => 'TCM',
			   'home.discoveryeurope.com' => 'Discovery Home',
			   'travelchannel.co.uk' => 'Travel',
			   'trouble.co.uk' => 'Trouble',
			   'tvasia.com' => 'Zee',
			   'tvtravelshop.co.uk' => 'Travel Shop',
			   'tttv.granadatv.co.uk' => 3,
			   'utv.co.uk' => 3,
			   'westcountry.carlton.com' => 3,
			   'yorkshire.granadatv.co.uk' => 3,
			   'knowledge.bbc.co.uk' => 'BBC Know',
			   'parliament.bbc.co.uk' => 'BBC Parl',
			  );
    return %channel_numbers;
}

# Return a hash mapping package names to lists of Ananova channel ids.
sub get_channel_pkgs() {
    my %xmltvid_to_ananovaid = reverse %{get_ch_to_output()};
    my %pkgs = (
		# Free digital channels.  The terrestrial analogue
		# versions are not included here because they come
		# under their own region package (eg 'Tyne Tees').  I
		# haven't included BBC1 Ireland, BBC1 Scotland
		# etc. because I don't know whether they're
		# universally available.
		#
		gratis => [qw(
digital.bbc1.bbc.co.uk digital.bbc2.bbc.co.uk carlton.com channel4.com
channel5.co.uk travelchannel.co.uk home.discoveryeurope.com
choice.bbc.co.uk knowledge.bbc.co.uk einstein.tv tcm.turner.com
sky-news.sky.com bloomberg.com news-24.bbc.co.uk parliament.bbc.co.uk
europe.cnn.com itn.co.uk boomerang.cartoonnetwork.com
channelhealth.tv ftv.com extreme.com qvc1.qvcuk.com tvtravelshop.co.uk
2.tvtravelshop.co.uk shop-tv.co.uk screenshop.co.uk
shop-america.tv-listings.ananova.com simplyshoppingtv.co.uk
christian-channel-europe.god-digital.com)],

		musicchoice => [qw(
blues.musicchoice.co.uk classical.musicchoice.co.uk
country.musicchoice.co.uk dance.musicchoice.co.uk
easy.musicchoice.co.uk gold.musicchoice.co.uk hits.musicchoice.co.uk
jazz.musicchoice.co.uk love.musicchoice.co.uk
rock.musicchoice.co.uk)],

		adult => [qw(
theadultchannel.co.uk adults-only-1.itv.co.uk adults-only-2.itv.co.uk
fantasy.televisionx.co.uk playboy.com
red-hot-all-girl.tv-listings.ananova.com)],

		factual => [qw(
animalplanet.discoveryeurope.com knowledge.bbc.co.uk food.carlton.com
dot-tv.tv-listings.ananova.com civilisations.discoveryeurope.com
discoveryeurope.com kids.discoveryeurope.com
plus-1.discoveryeurope.com sci-trek.discoveryeurope.com
travel.discoveryeurope.com wings.discoveryeurope.com einstein.tv
thehistorychannel.co.uk nationalgeographic.co.uk channelhealth.tv
biography-channel.biography.com plus-1.home.discoveryeurope.com
plus-1.thehistorychannel.co.uk home.discoveryeurope.com)],

		news => [qw(
news-24.bbc.co.uk parliament.bbc.co.uk bloomberg.com europe.cnn.com
sky-news.sky.com itn.co.uk)],

		# I couldn't decide what to call this ('ethnic'?) 
		# until I realized that all the channels come from the
		# same continent :-).
		#
		asia => [qw(
asianet-tv.com setindia.com asia1tv.com banglatv.com
pakistanichannel.com b4utv.com star-plus.startv.com tvasia.com)],

		sport => [qw(
british.eurosport.com sky-sports-1.sky.com extreme.com sport.itv.co.uk
sport-plus.itv.co.uk sport-select.itv.co.uk mutv.manutd.com
racingchannel.com eurosport.sky.com 2.sports.sky.com 3.sports.sky.com
news.sports.sky.com 1.sports.sky.com 3.sports.sky.com
extra.sports.sky.com 2.sports.sky.com)],

		# Of course actual 'entertainment' is subjective.
		entertainment => [qw(
box.tv-listings.ananova.com bravo.co.uk e4.channel4.com
challengetv.co.uk men.granadatv.co.uk itv-digital.men.granadatv.co.uk
plus.granadatv.co.uk plus.granadatv.co.uk itv2.itv.co.uk
sky-one.sky.com ondigital.sky-one.sky.com trouble.co.uk
uk-gold.flextech.telewest.co.uk uk-gold-2.flextech.telewest.co.uk
play.flextech.telewest.co.uk)],

		# 'misc' are just those that didn't fit in elsewhere.
		misc => [qw(
prime.bbc.com world-tv.bbc.com europe.cnbc.com ftv.com landscapetv.com
channel-9.tv-listings.ananova.com beti.tv studio.com utv2.utv.co.uk
choice.bbc.co.uk)],

		film => [qw(
sky-premier.sky.com cinema.carlton.com filmfour.channel4.com
extreme.filmfour.channel4.com plus-1.filmfour.channel4.com
world.filmfour.channel4.com box-office-digital.sky.com
2.moviemax.sky.com 3.moviemax.sky.com 4.moviemax.sky.com
5.moviemax.sky.com itvdigital.moviemax.sky.com moviemax.sky.com
cinema.sky.com 2.premier.sky.com 3.premier.sky.com 4.premier.sky.com
ondigital.premier.sky.com widescreen.premier.sky.com 2.cinema.sky.com
51.front-row.ntl.com 52.front-row.ntl.com 53.front-row.ntl.com
54.front-row.ntl.com front-row.ntl.com b4utv.com tcm.turner.com)],

		children => [qw(
uk.cartoonnetwork.com kids.discoveryeurope.com
disneychannel.disney.co.uk foxkids.co.uk plus-1.foxkids.co.uk
nickelodeon.co.uk nickelodeon.co.uk nickelodeon.co.uk
jr.nickelodeon.co.uk replay.nickelodeon.co.uk
boomerang.cartoonnetwork.com toon.disney.co.uk playhouse.disney.co.uk
plus-1.uk.cartoonnetwork.com plus-1.disneychannel.disney.co.uk)],

		religion => [qw(
christian-channel-europe.god-digital.com)],

		classics => [qw(
digitalclassics.tv tcm.turner.com uk-drama.flextech.telewest.co.uk
uk-gold.flextech.telewest.co.uk uk-gold-2.flextech.telewest.co.uk
uk-horizons.flextech.telewest.co.uk living.flextech.telewest.co.uk
play.flextech.telewest.co.uk uk-style.flextech.telewest.co.uk)],

		lifestyle => [qw(
breeze.granadatv.co.uk plus-1.home.discoveryeurope.com
home.discoveryeurope.com living.flextech.telewest.co.uk
uk-style.flextech.telewest.co.uk wellbeing.com)],

		music => [qw(
m2europe.com mtv.co.uk base.mtv.co.uk dance.mtv.co.uk hits.mtv.co.uk
blues.musicchoice.co.uk classical.musicchoice.co.uk
country.musicchoice.co.uk dance.musicchoice.co.uk
easy.musicchoice.co.uk gold.musicchoice.co.uk hits.musicchoice.co.uk
jazz.musicchoice.co.uk love.musicchoice.co.uk rock.musicchoice.co.uk
vh1online.co.uk classic.vh1online.co.uk)],

		comedy => [qw(paramountcomedy.com)],

		arts => [qw(
performancetv.co.uk digital.performancetv.co.uk artsworld.com)],

		# I hope that putting 'Travel Shop' etc in here is
		# correct.
		#
		shop => [qw(
qvcuk.com shop-tv.co.uk simplyshoppingtv.co.uk
shop-america.tv-listings.ananova.com qvc1.qvcuk.com
2.tvtravelshop.co.uk screenshop.co.uk
landmark-travel.tv-listings.ananova.com tvtravelshop.co.uk
wellbeing.com)],

		scifi => [qw(
cable.uk.scifi.com digital.uk.scifi.com)],

		travel => [qw(
travel.discoveryeurope.com 2.tvtravelshop.co.uk
landmark-travel.tv-listings.ananova.com travelchannel.co.uk
tvtravelshop.co.uk)],
	       );

    my %r;
    foreach (keys %pkgs) {
	my $ananova_ids = $r{$_} = [];
	foreach (@{$pkgs{$_}}) {
	    die if not defined;
	    my $aid = $xmltvid_to_ananovaid{$_};
	    die "cannot find Ananova id for $_" if not defined $aid;
	    push @$ananova_ids, $aid;
	}
    }
    return %r;
}
