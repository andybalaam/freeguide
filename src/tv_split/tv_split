#!/usr/bin/perl -w
# $Id$

=head1 NAME

tv_split - Split XMLTV listings into separate files for each channel and date.

=head1 SYNOPSIS

tv_split --output OUTPUT_FILE --day_start_time TIME [INPUT_FILE]

tv_split --help

=head1 DESCRIPTION

Read an XMLTV file and write out the same data into several separate
files, splitting into separate channels and/or days.

Where stop times of programmes are missing, guess them from the start
time of the next programme on the same channel.

tv_split sorts programmes into time order, and performs certain other
sorting and checking, but you are recommended to use tv_sort prior to
tv_split if advanced features are required.

B<--output OUTPUT_FILE> Write output to files specified by
OUTPUT_FILE.  OUTPUT_FILE may contain L<date(1)> style substitutions.
B<%channel> is substituted for the channel name.

For example, use
B<tv_split --output listings-%channel-%Y%m%d.xml input.xml>
to separate the XMLTV file input.xml into separate files for each day
and channel.  The files will be named e.g. "listings-BBC1-20020330.xml"

B<--day_start_time> The time at which a new day is deemed to start.
For example, B<--day_start_time 06:00> will mean that when listings are
split the new day will start at 6am (the default).  Perl-style dates
are accepted, but only the hour and minute are used.

=head1 SEE ALSO

L<xmltv(5)>.

=head1 AUTHOR

Andy Balaam, freeguide@artificialworlds.net

Adapted from tv_sort by Ed Avis and tv_grab_na by Jerry Veldhuis.

=cut

# ----------------------------------------------------------------------------

# Most of the first part of this is cut and pasted from tv_sort,
# and most of the second part is inspired by tv_grab_na's --listings
# option.

use strict;
use Date::Manip; Date_Init('TZ=UT');
use Log::TraceMessages qw<t d>; Log::TraceMessages::check_argv(); $| = 1;
use Data::Dumper;
use Getopt::Long;

use XMLTV;
use XMLTV::Usage <<END
$0: split listings by day and channel
usage: $0 --output OUTPUT_FILE [--day_start_time TIME] [INPUT_FILE]
       $0 --help
END
;

# Memoize some subroutines if possible
eval { require Memoize };
if ($@) {
    warn "tv_split - could not load Memoize module, things will run slowly";
}
else {
    foreach (qw/Date_Cmp ParseDate programme_eq/) {
	Memoize::memoize($_) or die "cannot memoize $_: $!";
    }
    # clumpidx_cmp() isn't memoized, since it uses undef arguments and
    # they cause warnings.
    #
}



# Prototype declarations

sub get_adjusted_date( $ );

sub programme_cmp();
sub chan_cmp( $$ );
sub clumpidx_cmp( $$ );
sub overlap( $$ );
sub add_stop( $ );
sub programme_eq( $$ );

my ($opt_help, $opt_output, $opt_day_start_time);
GetOptions('help' => \$opt_help, 'output=s' => \$opt_output, 
	'day_start_time=s' => \$opt_day_start_time)
  or usage(0);
usage(1) if $opt_help;
my $filename;
if (@ARGV == 0) {
    $filename = '-';
}
elsif (@ARGV == 1) {
    $filename = $ARGV[0];
}
elsif (@ARGV >= 2) {
    usage();
}
else { die }

# Check we have an output file
if (!$opt_output) {
	usage(0);
}

# Sort out the day start time
if(!$opt_day_start_time) {
	$opt_day_start_time = "06:00";
}
my ($tmp1,$tmp2,$tmp3,$day_start_hour, $day_start_min,$tmp4)=Date::Manip::Date_Split(ParseDateString($opt_day_start_time));

my ($encoding, $credits, $channels, $progs) = @{XMLTV::parsefile($filename)};
my @progs = @$progs;

# Split up programmes according to channel
my %chan;
foreach (@progs) {
    push @{$chan{$_->{channel}}}, $_;
}

# Sort each channel individually, and guess stop times.
foreach (keys %chan) {
    @{$chan{$_}} = sort programme_cmp @{$chan{$_}};
    add_stop($chan{$_});
}

# Remove duplicates and sanity-check that there is no overlap on a
# channel.
#
foreach (keys %chan) {
	
    my $progs = $chan{$_};
    my @new_progs;
    die if not @$progs;
    my $first = shift @$progs;
    while (@$progs) {
	my $second = shift @$progs;
	die if not defined $first or not defined $second;
	if (overlap($first, $second)) {
	    if (programme_eq($first, $second)) {
		# Quietly drop the duplicate.  We could have done the
		# programme_eq() step first but I thought (perhaps
		# wrongly) that it would be expensive, and best called
		# only when we know there is an overlap.  No overlap
		# implies not equal.
		#
		next;
	    }
	    else {
		local $^W = 0;
		warn <<END
overlapping programmes on channel $_:
    $first->{title}->[0]->[0]\tat $first->{start}-|$first->{stop}
and $second->{title}->[0]->[0]\tat $second->{start}-|$second->{stop}
END
  ;
	    }
	}
	push @new_progs, $first;
	$first = $second;
    }
    # Got to the last element.
    push @new_progs, $first;
    $chan{$_} = \@new_progs;
}

# ----------------------------------------------------------------------------

# Here's where we divert from tv_sort and start using my own code,
# with ideas and inspiration from tv_grab_na:

# Are we splitting by channel?
my $split_by_channel = $opt_output =~ /%channel/;

# Are we splitting by date?
my $opt_output_nochan = $opt_output;
$opt_output_nochan =~ s/%channel//;
my $split_by_date = !(UnixDate("now", $opt_output_nochan) eq $opt_output_nochan );

# Declare the writer that will be used to write out XMLTV
my $writer;

if($split_by_date) {
	
	if($split_by_channel) {
		print STDERR "tv_split - Splitting listings by date and channel.\n";
		
		if(!%$channels) {
			die("tv_split - No channels listed in input xml file.");
		}
		
		my $current_date = 0;
		# Stays blank until we deal with the first programme
		
		foreach my $this_chan (values %$channels) {
		
			# Find all the programmes in this channel
			my %this_channel = %$this_chan;
			
			if(!$chan{ $this_channel{id} }) {
				die("tv_split - No programmes listed in input xml file.");
			}
			
			my @this_chan_progs = @{ $chan{ $this_channel{id} } };
		
			# For each programme
			foreach my $this_prog (@this_chan_progs) {

				# Find the date of the current programme
				my $prog_date = get_adjusted_date( $this_prog->{start} );
				
				# Have we moved to a new day (or just started)?
				if(!$current_date || Date_Cmp($current_date, $prog_date) < 0) {

					# Close the last file if there is one
					if($writer) {
						$writer->end();
					}
					
					# Update to the new programme's date
					$current_date = $prog_date;
					
					# Create the file and set up output to it
					my $filename = $opt_output;
					$filename =~ s/%channel/$this_chan->{id}/;
					$filename = UnixDate($current_date, $filename);
		
					my $file = new IO::File(">$filename");
		
					$writer = new XMLTV::Writer(encoding => $encoding, 
						credits => $credits, OUTPUT => $file);
		
  					$writer->start({ 'generator-info-name' => 'tv_split' });
  		
					# Write out the channel we're writing
  					$writer->write_channel($this_chan);
					
				}
				
				# Write out the programme
				$writer->write_programme($this_prog);
				
			}
			
			# Set current date to 0 to we're beginning again
			$current_date = 0;
			
		}
		
		$writer->end();
		
	} else {
		
		print STDERR "Splitting listings by date only.\n";
		
		# Sort back into just date order
		@progs = sort programme_cmp @progs;
		
		my $current_date = 0;
		# Stays blank until we deal with the first programme
		
		# For each programme
		foreach my $this_prog (@progs) {

			# Find the date of the current programme
			my $prog_date = get_adjusted_date( $this_prog->{start} );
			
			# Have we moved to a new day (or just started)?
			if(!$current_date || Date_Cmp($current_date, $prog_date) < 0) {

				# Close the last file if there is one
				if($writer) {
					$writer->end();
				}
				
				# Update to the new programme's date
				$current_date = $prog_date;
						
				# Create the file and set up output to it
				my $filename = $opt_output;
				$filename = UnixDate($current_date, $filename);
		
				my $file = new IO::File(">$filename");
		
				$writer = new XMLTV::Writer(encoding => $encoding, 
					credits => $credits, OUTPUT => $file);
		
  				$writer->start({ 'generator-info-name' => 'tv_split' });
  		
				# Write out all the channels
  				$writer->write_channels($channels);
				
			}
			
			# Write out the programme
			$writer->write_programme($this_prog);
			
		}
		
		$writer->end();
		
	}
	
	
} elsif($split_by_channel) {
	print STDERR "tv_split - Splitting listings by channel only.\n";
	
	if(!%$channels) {
		die("tv_split - No channels listed in input xml file.");
	}
	
	foreach (values %$channels) {
		
		# Create the file and set up output to it
		my $filename = $opt_output;
		$filename =~ s/%channel/$_->{id}/;
		
		my $file = new IO::File(">$filename");
		
		$writer = new XMLTV::Writer(encoding => $encoding, 
			credits => $credits, OUTPUT => $file);
		
  		$writer->start({ 'generator-info-name' => 'tv_split' });
  		
		# Write out the channel we're writing
  		$writer->write_channel($_);
		
		# Write out the programmes for this channel
		my %this_channel = %$_;
		my @this_chan_progs = @{$chan{ $this_channel{id} }};
		
		foreach my $this_prog (@this_chan_progs) {	
			$writer->write_programme($this_prog);
		}
		
		$writer->end();
		$file->close();
		
	}
	
} else {
	
	# Not splitting at all - quit with an error
	
	die "tv_split - Not splitting listings by date or channel - 
	there's no point using tv_split unless you specify your output 
	file names as containing either channel names or dates.  Try
	tv_split --help for more information."
	
}


sub get_adjusted_date( $ )
{
	my ($original_date) = @_;
	
	# Remove the time zone by taking the first word in the original date
	$original_date =~ /^(\S*)/;
	$original_date = $1;
	
	my $parsed_date = ParseDate($original_date);
	
	# Split this date into bits
	my ($y,$m,$d,$h,$mn,$s)=Date::Manip::Date_Split($parsed_date);

	# If it is before the start time, move to the previous day
	if($h < $day_start_hour || ($h==$day_start_hour && $mn < $day_start_min)) {
					
		# Set the date to the previous day
		$d--;
		
	}
	
	return Date::Manip::ParseDate( "$y-$m-$d" );
	
}




# ----------------------------------------------------------------------------

# Subroutines from tv_sort

# Compare two programme hashes.
sub programme_cmp() {
    my $xa = $a; my $xb = $b;
    my $r;

    # Assume that {start} is always there, as it should be.
    my ($a_start, $b_start) = (ParseDate($xa->{start}), ParseDate($xb->{start}));
    if (not defined $a_start) {
	die "cannot parse start time: $xa->{start}";
    }
    if (not defined $b_start) {
	die "cannot parse start time: $xb->{start}";
    }
    $r = Date_Cmp($a_start, $b_start);
    t "compare start times: " . d $r;
    return $r if $r;

    # But {stop} is optional.  If both progs have stop we sort on it,
    # otherwise it is not used.  (It doesn't seem right to have
    # undefined values taking part in sort comparisons, and besides,
    # it stops tv_sort from being idempotent.)
    #
    my ($a_stop_u, $b_stop_u) = ($xa->{stop}, $xb->{stop});
    if (defined $a_stop_u and defined $b_stop_u) {
	my ($a_stop, $b_stop) = (ParseDate($a_stop_u), ParseDate($b_stop_u));
	if (not defined $a_stop) {
	    die "cannot parse stop time: $a_stop_u";
	}
	if (not defined $b_stop) {
	    die "cannot parse stop time: $b_stop_u";
	}
	$r = Date_Cmp($a_stop, $b_stop);
	t "compare stop times: " . d $r;
	return $r if $r;
    }

    # Channel.  Ideally would sort on pretty name, but no big deal.
    $r = $xa->{channel} cmp $xb->{channel};
    t "compare channels: " . d $r;
    return $r if $r;

    $r = clumpidx_cmp($xa->{clumpidx}, $xb->{clumpidx});
    t "compare clumpidxes: " . d $r;
    return $r if $r;

    t 'do not sort';
    # No warning, because we'll be weeding out duplicates later.  This
    # routine should just do what it's told and compare.
    #
    return 0;
}


# Compare indexes-within-clump
sub clumpidx_cmp( $$ ) {
    my ($A, $B) = @_;

    if (not defined $A and not defined $B) {
	return 0; # equal
    }
    elsif ((not defined $A and defined $B)
	   or (defined $A and not defined $B)) {
	warn "mismatching clumpidxs: one programme has, one doesn't";
	return undef;
    }
    elsif (defined $A and defined $B) {
	$A =~ m!^(\d+)/(\d+)$! or die "bad clumpidx $A";
	my ($ai, $num_in_clump) = ($1, $2);
	$B =~ m!^(\d+)/(\d+)$! or die "bad clumpidx $B";
	my $bi = $1;
	if ($2 != $num_in_clump) {
	    warn "clumpidx's $A and $B don't match";
	    return undef;
	}
	
	return $ai <=> $bi;
    }
    else { die }
}


# Test whether two programmes overlap in time.  This takes account of
# start time and stop time, and clumpidx (so two programmes with the same
# start and stop times, but different places within the clump, are not
# considered to overlap).
#
sub overlap( $$ ) {
    my ($xa, $xb) = @_;

    my ($xa_start, $xb_start) = (ParseDate($xa->{start}), ParseDate($xb->{start}));
    die "cannot parse start time: $xa->{start}" if not defined $xa_start;
    die "cannot parse start time: $xb->{start}" if not defined $xb_start;
    my ($xa_stop, $xb_stop);	
    for ($xa->{stop}) {
	if (defined) {
	    $xa_stop = ParseDate($_);
	    die "cannot parse stop time: $_" if not defined $xa_stop;
	}
    }
    for ($xb->{stop}) {
	if (defined) {
	    $xb_stop = ParseDate($_);
	    die "cannot parse stop time: $_" if not defined $xb_stop;
	}
    }

    # If we don't know the stop times we can't do an overlap test; if
    # we know only one stop time we can do only one half of the
    # test.  We assume no overlap if we can't prove otherwise.
    #
    { local $^W = 0;
      t "xa: $xa_start -| $xa_stop"; t "xb: $xb_start -| $xb_stop" }
    if ((
	 # XB starts while XA on
	 defined $xa_stop and Date_Cmp($xa_start, $xb_start) <= 0
	 and Date_Cmp($xb_start, $xa_stop) < 0
	) or (
	      # XA starts while XB on
	      defined $xb_stop and Date_Cmp($xb_start, $xa_start) <= 0
	      and Date_Cmp($xa_start, $xb_stop) < 0
	     )
       ) {
	my $cmp = clumpidx_cmp($xa->{clumpidx}, $xb->{clumpidx});
	if (not defined $cmp) {
	    # No clumpidxes, so must overlap.  (Also happens if
	    # the two indexes were not comparable - but that will
	    # have been warned about already.)
	    #
	    t 'no clumpidxes, overlap';
	    return 1;
	}
	t 'compared clumpidxes: same? ' . not $cmp;
	return not $cmp;
    }
    t 'no time overlap, returning 0';
    return 0;
}


# Add 'stop time' to a list of programmes (hashrefs).
# The stop time of a programme is the start time of the next.
#
# Parameters: reference to list of programmes, sorted by date, to be
# shown consecutively (except for 'clumps').
#
# Modifies the list passed in.
#
sub add_stop( $ ) {
    die 'usage: add_stop(ref to list of programme hashrefs)' if @_ != 1;
    my $l = shift;

    my $this_start; # Start time of current clump
    my $next_start; # Start time of next clump
    my $next_next_start; # Start time of next-but-one clump
    for (my $i = $#$l; $i >= 0; $i--) {
	my $this = $l->[$i];
	my $clumpidx = $this->{clumpidx};
	$clumpidx = '0/1' if not defined $clumpidx;
	$clumpidx =~ s!/\d+$!!; # not interested in clump size
	$clumpidx =~ m!^\d+$! or die "bad clumpidx '$_->{clumpidx}'";
	
	$this_start = $this->{start};
	if (not defined $this->{stop} and defined $next_start) {
	    if ($next_start ne $this_start) {
		$this->{stop} = $next_start;
	    }
	    else {
		# Special handling for overlapping programmes: going
		# backwards in time and finding one programme
		# immediately before another with the same start time.
		# We should guess the stop time to be the same as the
		# stop time for the overlapping programme.
		#
		# This is for the case you have the following three
		# programmes:
		#   A from 00 to ?
		#   A from 00 to ?
		#   B from 01 to 02
		# We need to make the two As have the same stop time.
		#
		$this->{stop} = $next_next_start
		  if defined $next_next_start;
	    }
	}

	if ($clumpidx == 0) {
	    # First programme in clump - we're going backwards, so
	    # next time we will move on to the previous clump.
	    #
	    if (not defined $next_start
		or $this_start ne $next_start) {
		($next_start, $next_next_start) = ($this_start, $next_start);
	    }
	}
    }
}


# Equality of two programmes.  The programme details are just text, so
# we can stringify the whole data structure and compare that.  We do
# assume that Data::Dumper will list hashes in a consistent order.  We
# don't care what the order is, just as long as it's the same each
# time.
#
sub programme_eq( $$ ) {
    t 'comparing programmes ' . d($_[0]) . ' and ' . d($_[1]);
    my $r = Dumper($_[0]) eq Dumper($_[1]);
    t "equal? $r";
    return $r;
}
